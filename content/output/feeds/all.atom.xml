<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>A Pelican Blog</title><link href="/" rel="alternate"></link><link href="/feeds/all.atom.xml" rel="self"></link><id>/</id><updated>2016-08-27T00:00:00+00:00</updated><entry><title>SQLAlchemy Transaction 관리 Practice 공유</title><link href="/SQLAlchemy-Transaction-%EA%B4%80%EB%A6%AC-Practice-%EA%B3%B5%EC%9C%A0.html" rel="alternate"></link><published>2016-08-27T00:00:00+00:00</published><author><name></name></author><id>tag:,2016-08-27:SQLAlchemy-Transaction-관리-Practice-공유.html</id><summary type="html">&lt;h2&gt;개요&lt;/h2&gt;
&lt;p&gt;기본적으로 &lt;code&gt;SQLAlchemy&lt;/code&gt;에서는 (&lt;code&gt;autocommit=True&lt;/code&gt; 옵션을 주지 않는 이상) 수동으로 트랜잭션을 관리해야 한다. 예를 들면 이런 거다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;session&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Session&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;new_user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;User&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_user&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;commit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이렇게 항상, &lt;code&gt;session.commit()&lt;/code&gt; 혹은 &lt;code&gt;session.rollback()&lt;/code&gt;을 붙여주어야 트랜잭션이 끝나면서 변경 내용이 반영된다. 이렇게 간단한 수준의 코드라면 별 문제 없겠지만, 만약 큰 파일을 읽어서 모든 내용을 DB에 저장하는 작업을 하나의 트랜잭션에서 관리해야 한다면?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;session&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Session&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="c1"&gt;# very complex logic with a huge file...&lt;/span&gt;
&lt;span class="c1"&gt;# ...&lt;/span&gt;
&lt;span class="c1"&gt;# many lines...&lt;/span&gt;
&lt;span class="c1"&gt;# ...&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;commit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;물론 이렇게도 할 수야 있겠지만, 개발자 입장에서 현재 어떤 세션 컨텍스트 안에서 작업을 하는 중인지 헷갈릴 가능성이 높다. 게다가 롤백을 위해 예외 관리를 해야 한다면? 복잡성은 더 늘어날 것이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Transaction Context 관리&lt;/h2&gt;
&lt;p&gt;이런 문제를 해결하기 위해, Python의 &lt;code&gt;with&lt;/code&gt;절을 이용해 트랜잭션 관리의 가독성을 높여보자. (참고: &lt;a href="http://docs.sqlalchemy.org/en/latest/orm/session_basics.html#when-do-i-construct-a-session-when-do-i-commit-it-and-when-do-i-close-it"&gt;When do I construct a Session, when do I commit it, and when do I close it?&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;먼저 &lt;code&gt;contextmanager&lt;/code&gt;를 이용해 &lt;code&gt;with&lt;/code&gt;절 문법을 사용할 수 있게 만든다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;contextlib&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;contextmanager&lt;/span&gt;

&lt;span class="nd"&gt;@contextmanager&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;gettx&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;session&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Session&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;session&lt;/span&gt;
        &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;commit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rollback&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;raise&lt;/span&gt;
    &lt;span class="k"&gt;finally&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;그럼 이 함수를 이용해서 첫 번 째 예제를 다시 작성해보자.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;gettx&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;new_user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;User&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_user&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;with&lt;/code&gt;절을 빠져 나오면서 자동으로 트랜잭션은 닫히고 커넥션 자원도 반환된다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;수동 Transaction을 자동으로 관리&lt;/h2&gt;
&lt;p&gt;위 방법을 이용해서 트랜잭션 관리를 편하게 할 수 있었다. 그런데 &lt;code&gt;with&lt;/code&gt;을 쓰기도 귀찮다면? 큰 코드 단위를 하나의 트랜잭션으로 관리하려면 어쩔 수 없이 &lt;code&gt;with&lt;/code&gt; 등을 이용해 트랜잭션을 관리해야 하겠지만, 매 쿼리마다 트랜잭션이 열리고 닫혀도 상관없는 경우도 많을 것이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SQLAlchemy&lt;/code&gt; 코드가 있는 부분을 service layer로 분리해서 사용할 때, &lt;code&gt;Python decorator&lt;/code&gt;를 이용하면 자동으로 트랜잭션 관리도 가능하게 할 수 있다. 먼저 데코레이터 부분을 보자.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;opentx&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wrap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  &lt;span class="c1"&gt;# 이미 열려있는 트랜잭션을 쓰는 부분&lt;/span&gt;
            &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;gettx&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  &lt;span class="c1"&gt;# 새로운 트랜잭션을 여는 부분&lt;/span&gt;
            &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;hasattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;_sa_instance_state&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                &lt;span class="c1"&gt;# 트랜잭션이 닫혀도 object의 attributes에 접근 할 수 있게 함&lt;/span&gt;
                &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;expunge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;wrap&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;서비스 레이어의 코드를 보자.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;UserService&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="nd"&gt;@classmethod&lt;/span&gt;
    &lt;span class="nd"&gt;@opentx&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;new_user&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_user&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;마지막으로 이 서비스 함수를 사용하는 코드를 보자.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 트랜잭션을 수동으로 관리하고 싶은 경우&lt;/span&gt;
&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;gettx&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;new_user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;User&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;UserService&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_user&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# 트랜잭션을 자동으로 관리하고 싶은 경우&lt;/span&gt;
&lt;span class="n"&gt;new_user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;User&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;UserService&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_user&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이런식으로 하나의 메소드를 원하는 트랜잭션 안에서 자유롭게 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;더 좋은 방법을 아시는 분은 공유해주시면 감사하겠습니다!&lt;/p&gt;</summary><category term="python"></category><category term="sqlalchemy"></category></entry><entry><title>SQLAlchemy-PostgreSQL에서의 JSON 타입 업데이트</title><link href="/SQLAlchemy-PostgreSQL%EC%97%90%EC%84%9C%EC%9D%98-JSON-%ED%83%80%EC%9E%85-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8.html" rel="alternate"></link><published>2016-08-26T00:00:00+00:00</published><author><name></name></author><id>tag:,2016-08-26:SQLAlchemy-PostgreSQL에서의-JSON-타입-업데이트.html</id><summary type="html">&lt;p&gt;&lt;code&gt;PostgreSQL 9.3&lt;/code&gt; 과 &lt;code&gt;SQLAlchemy&lt;/code&gt;를 이용해서 JSON 타입의 컬럼을 업데이트 하려고 했는데 되질 않았다. 찾다보니 한 아티클&lt;a href="https://bashelton.com/2014/03/updating-postgresql-json-fields-via-sqlalchemy/"&gt;Updating PostgreSQL JSON fields via SQLAlchemy&lt;/a&gt;을 찾게 되어 내용을 정리해본다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;기본적인 업데이트 방법&lt;/h2&gt;
&lt;p&gt;아마 다들 알다시피, &lt;code&gt;SQLAlchemy&lt;/code&gt;에서는 다음과 같은 방법으로 간단하게 update 쿼리를 날릴 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;session&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Session&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;User&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;User&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;user_id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;new_name&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;commit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;그런데 만약 업데이트 하려는 컬럼이 JSON 타입이라면?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;session&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Session&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;User&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;User&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;user_id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;json_field&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;key&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;value&amp;#39;&lt;/span&gt;  &lt;span class="c1"&gt;# 이렇게?&lt;/span&gt;
&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;json_field2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;key2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;value2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;  &lt;span class="c1"&gt;# 아님 이렇게?&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;commit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;안된다.&lt;/p&gt;
&lt;p&gt;왜? &lt;code&gt;PostgreSQL&lt;/code&gt; 9.3을 &lt;code&gt;SQLAlchemy&lt;/code&gt;로 이용할 때 생기는 문제라고 한다. 9.5에서는 JSONB 타입 컬럼의 경우 자동으로 업데이트가 되도록 변경 되었지만, 여전히 JSON 타입 컬럼에 대해서는 지원하지 않는다고 한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;그럼 어떻게 하지?&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sqlalchemy.orm.attributes&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;flag_modified&lt;/span&gt;

&lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;User&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;User&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;user_id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;json_field&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;key&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;value&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;flag_modified&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;json_field&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;commit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;된다. 강제로 해당 컬럼을 업데이트 하겠다는 신호를 주는 듯 하다.&lt;/p&gt;
&lt;p&gt;직접적으로 세션을 이용하는 방법도 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;User&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;User&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;user_id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;json_field&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;key&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;value&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}})&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;commit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="python"></category><category term="sqlalchemy"></category><category term="postgresql"></category></entry><entry><title>Python/Django에서 Celery로 Task Queue 구축</title><link href="/Python/Django%EC%97%90%EC%84%9C-Celery%EB%A1%9C-Task-Queue-%EA%B5%AC%EC%B6%95.html" rel="alternate"></link><published>2016-04-05T00:00:00+00:00</published><author><name></name></author><id>tag:,2016-04-05:Python/Django에서-Celery로-Task-Queue-구축.html</id><summary type="html">&lt;h2&gt;개요&lt;/h2&gt;
&lt;p&gt;서비스를 만들다보면 유저에게 특정 요청이 들어오면 이메일을 보내야 할 때가 있다. 그런데 이 때, 메일 서버의 상태가 좀 이상하다면? 혹은 서버에 이미 보내야 할 메일이 산더미처럼 쌓여있다면? 이메일 전송이 지연되면 유저의 요청도 지연되고, 유저는 기다리다 지쳐 서비스 이용을 관두게 된다 ㅜㅜ 그럼 어떡하지?&lt;/p&gt;
&lt;p&gt;일단 유저에게는 요청이 완료되었다는 응답을 보내고, 이메일을 보내는 과정은 서버가 알아서 기다리고 알아서 처리하게 하는 방법이 있다. 실제로 우리도 어떤 서비스를 가입하면 가입 환영 메일을 받는데, 가입하자마자 오는 경우도 있지만 시간이 꽤 지난 후에 메일을 받는 경우도 많다.&lt;/p&gt;
&lt;p&gt;태스크 큐&lt;code&gt;task queue&lt;/code&gt;를 이용하면 이런 비동기 작업을 수월하게 할 수 있다. 이메일을 보내라는 요청이 들어오면 일단 큐에 이메일을 보내는 작업&lt;code&gt;task&lt;/code&gt;을 넣어놓고, 결과에 상관없이 유저에게는 응답을 보낸다. python에서는 &lt;a href="http://www.celeryproject.org/"&gt;&lt;code&gt;celery&lt;/code&gt;&lt;/a&gt;라는 아주 인기 높은 분산 태스크 큐가 있다. &lt;code&gt;celery&lt;/code&gt;와 함께라면 당신도 억울하게 유저를 잃지 않을 수 있다. 추가로 &lt;code&gt;celery&lt;/code&gt;의 작업들을 모니터링 할 수 있는 &lt;code&gt;flower&lt;/code&gt;까지 알아보자.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Message Broker&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;celery&lt;/code&gt;에서 실제로 작업을 처리하는 프로세스를 워커&lt;code&gt;worker&lt;/code&gt;라고 하는데, 이 워커가 일을 하려면 작업을 전달해주는 메세지 브로커&lt;code&gt;message broker&lt;/code&gt;가 필요하다. 그리고 이 메세지 브로커는 &lt;code&gt;celery&lt;/code&gt; 내부에 있는 것이 아니고 따로 설치를 해줘야 한다.&lt;/p&gt;
&lt;p&gt;대표적으로 &lt;code&gt;rabbitmq&lt;/code&gt;와 &lt;code&gt;redis&lt;/code&gt;가 있는데, 데이터베이스를 쓸 수도 있고 다른 프로그램을 쓸 수도 있지만, (공식적으로도) &lt;a href="http://docs.celeryproject.org/en/latest/getting-started/brokers/index.html"&gt;추천하지 않는다&lt;/a&gt;. 그냥 &lt;code&gt;rabbitmq&lt;/code&gt;를 쓰자.&lt;/p&gt;
&lt;h3&gt;RabbitMQ 설치&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.rabbitmq.com/download.html"&gt;공식 문서&lt;/a&gt;를 참조하는게 좋다. 내가 쓰는 OS만 대표적으로 옮겨 놓겠다.&lt;/p&gt;
&lt;h4&gt;OS X&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;brew update
brew install rabbitmq
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;RHEL&lt;/h4&gt;
&lt;p&gt;무슨 이유인지는 모르겠는데 &lt;code&gt;erlang&lt;/code&gt;, &lt;code&gt;rabbitmq&lt;/code&gt; 둘 다 &lt;code&gt;yum&lt;/code&gt;에 기본적으로 등록이 안 되어있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# install erlang&lt;/span&gt;
wget http://packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm
rpm -Uvh erlang-solutions-1.0-1.noarch.rpm
yum install erlang

&lt;span class="c1"&gt;# install rabbitmq-server&lt;/span&gt;
wget http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0-1.noarch.rpm
rpm -Uvh rabbitmq-server-3.6.0-1.noarch.rpm
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;RabbitMQ 실행&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;rabbitmq-server
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;브로커가 떴다!&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Celery Worker&lt;/h2&gt;
&lt;p&gt;실제로 워커를 띄우기 위해 &lt;code&gt;celery&lt;/code&gt;를 적용해보자. 본 포스트에서는 &lt;code&gt;django&lt;/code&gt;와 연동하는 예제(&lt;a href="http://docs.celeryproject.org/en/latest/django/first-steps-with-django.html"&gt;공식 문서&lt;/a&gt;도 같이 참조하면 좋다)을 보여주겠다.&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h3&gt;Celery 설치&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip install celery
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Celery 설정&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;celery&lt;/code&gt; 애플리케이션을 설정하고 생성하기 위해서 &lt;code&gt;django&lt;/code&gt;의 설정 디렉토리(최초 &lt;code&gt;settings.py&lt;/code&gt;가 있는 디렉토리)에 &lt;code&gt;celery.py&lt;/code&gt; 파일을 만들고 다음 코드를 작성한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;__future__&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;absolute_import&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;celery&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Celery&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;django.conf&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;settings&lt;/span&gt;

&lt;span class="c1"&gt;# celery 앱에 django의 settings 값을 주입한다.&lt;/span&gt;
&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;environ&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setdefault&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;DJANGO_SETTINGS_MODULE&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;environ&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;DJANGO_SETTINGS_MODULE&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Celery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;your_django_app_name&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;같은 디렉토리의 &lt;code&gt;__init__.py&lt;/code&gt;에 다음과 같이 입력한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;your_django_app_name.celery&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;celery_app&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;django&lt;/code&gt;의 &lt;code&gt;settings.py&lt;/code&gt;에 &lt;code&gt;celery&lt;/code&gt;가 &lt;code&gt;rabbitmq&lt;/code&gt;와 연결할 수 있도록 다음과 같은 설정을 추가한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# rabbitmq의 기본 유저, 기본 호스트, 기본포트(5672)로 연결한다.&lt;/span&gt;
&lt;span class="n"&gt;BROKER_URL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;amqp://guest:guest@localhost//&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이제 &lt;code&gt;django&lt;/code&gt;가 구동되면서 &lt;code&gt;celery&lt;/code&gt;를 생성하게 되고, 사용할 수 있다.&lt;/p&gt;
&lt;h3&gt;Celery Task 작성&lt;/h3&gt;
&lt;p&gt;서두에 말했던 것과 같이 이메일을 보내는 간단한 작업을 작성해보자. 간단하게 &lt;code&gt;django&lt;/code&gt;의 &lt;code&gt;send_mail&lt;/code&gt; 메소드를 이용하자.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;celery&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;shared_task&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;django.core.mail&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;send_mail&lt;/span&gt;

&lt;span class="c1"&gt;# shared_task는 하나의 프로젝트에서 여러개의 celery 인스턴스를 생성할 경우, 인스턴스에서 공유가 가능한 작업을 뜻한다&lt;/span&gt;
&lt;span class="nd"&gt;@shared_task&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;send_email&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fromm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;html_content&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;send_mail&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fromm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;html_message&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;html_content&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;WOW! 엄청 간단하다. 그럼 이제 실제로 이 작업을 사용해보자.&lt;/p&gt;
&lt;h3&gt;Django View 작성&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;@shared_task&lt;/code&gt;로 선언된 함수를 실행할 때, &lt;code&gt;delay()&lt;/code&gt;를 통해 실행하면&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt; 자동으로 메세지 브로커를 통해 작업이 워커로 날아간다! 너무 편하다!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;your_tasks_path&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;send_email&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;some_controller_method&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="n"&gt;send_email&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;my_title&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;my_content&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;noreply@email.com&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;target@email.com&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Celery Worker 프로세스 구동&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;django&lt;/code&gt;의 루트 디렉토리로 이동한 후, 다음 명령어로 메세지 브로커를 통해 받은 작업을 처리할 워커를 띄운다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;celery worker -A your_django_app_name -l info
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;콘솔에 이런저런 로그가 뜨면서 &lt;code&gt;rabbitmq&lt;/code&gt;와 연결되었다는 메세지를 확인하면 성공이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Flower를 통한 Celery 모니터링&lt;/h2&gt;
&lt;p&gt;유저의 HTTP 요청은 이메일 전송 성공 여부에 상관없이 성공 응답(200)을 뱉는다. 그럼 실제로 이메일 전송 작업이 성공했는지는 어떻게 알지? 걱정마라. &lt;code&gt;celery&lt;/code&gt;를 모니터링 할 수 있는 오픈소스인 &lt;a href="http://flower.readthedocs.org/en/latest/"&gt;&lt;code&gt;flower&lt;/code&gt;&lt;/a&gt;가 있다.&lt;/p&gt;
&lt;h3&gt;Flower 설치&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip install flower
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Flower 실행&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;django&lt;/code&gt;의 루트 디렉토리로 이동한 후, 다음 명령어로 &lt;code&gt;flower&lt;/code&gt; 웹 인스턴스를 띄운다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 기본 포트는 5555이다&lt;/span&gt;
flower -A your_django_app_name
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;rabbitmq&lt;/code&gt;와 &lt;code&gt;celery&lt;/code&gt; 워커가 실행되어 있다면 정상적으로 인스턴스가 구동된다. &lt;code&gt;localhost:5555&lt;/code&gt;로 접속하면 &lt;a href="http://flower.readthedocs.org/en/latest/screenshots.html"&gt;멋진 화면&lt;/a&gt;을 볼 수 있다. 이렇게 간단하게 괜찮은 모니터링 툴을 이용할 수 있다니 ㅜㅜ&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;&lt;code&gt;django&lt;/code&gt;와 상관없이 python에서는 모두 사용 가능하다.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;&lt;code&gt;delay()&lt;/code&gt;를 안 붙이면 그냥 평범한 함수처럼 실행된다.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="python"></category><category term="django"></category><category term="celery"></category></entry><entry><title>Python Asyncio</title><link href="/Python-Asyncio.html" rel="alternate"></link><published>2016-03-27T00:00:00+00:00</published><author><name></name></author><id>tag:,2016-03-27:Python-Asyncio.html</id><summary type="html">&lt;h2&gt;개요&lt;/h2&gt;
&lt;p&gt;파이썬 3.3에 추가된 &lt;code&gt;asyncio&lt;/code&gt;는, 동시성 문제를 코루틴&lt;code&gt;coroutine&lt;/code&gt; 기반으로 처리하는 비동기 IO 라이브러리다. 동시성 문제를 처리하는 방법은 대표적으로 쓰레드와 콜백 패턴이 있다.&lt;/p&gt;
&lt;h3&gt;Thread&lt;/h3&gt;
&lt;p&gt;가장 대표적인 방법이다. 대중적인 방법이므로 이해도 쉽고 적용도 쉽다. 그런데 쓰레드에는 다음과 같은 문제가 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;쓰레드를 생성하는데 드는 오버헤드&lt;/li&gt;
&lt;li&gt;쓰레드를 만들 때마다 추가되는 메모리&lt;/li&gt;
&lt;li&gt;이것은 python만의 문제인데, &lt;code&gt;GIL(global interpreter lock)&lt;/code&gt;이라는 개념 때문에 python의 쓰레드는 일반적인 쓰레드 처럼 동작하지 않는 문제가 있다.&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;쓰레드가 문제라면 프로세스를 쓰면 되긴 하지만, 프로세스는 쓰레드보다 오버헤드가 훨씬 크기 때문에 멀티코어를 이용한 CPU 연산 작업이 아닌, 일반적인 상황에서는 크게 얻는 이득은 없다.&lt;/p&gt;
&lt;h3&gt;Callback&lt;/h3&gt;
&lt;p&gt;그럼 쓰레드를 사용하지 않는다면? 대안은 event-driven이다. Node.js등에서 많이 사용하는 콜백 패턴 등이 대표적이다. 그런데 콜백 패턴은,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;조금만 복잡해지면 가독성이 심하게 저하되어 개발자가 코드의 흐름을 읽기가 힘들어진다는 단점(&lt;a href="https://www.google.co.kr/webhp?sourceid=chrome-instant&amp;amp;ion=1&amp;amp;espv=2&amp;amp;es_th=1&amp;amp;ie=UTF-8#q=%EC%BD%9C%EB%B0%B1%20%EC%A7%80%EC%98%A5"&gt;콜백 지옥&lt;/a&gt;으로 검색하면 수많은 포스트를 볼 수 있다.)이 있다.&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://yisangwook.tumblr.com/post/90919749574/farewell-node-js-tj-holowaychuk"&gt;아무튼 콜백에 존재하는 수많은 단점들…&lt;/a&gt;도 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;그럼 코루틴은 어떨까? 코루틴도 event-driven으로 동시성 문제를 해결한다. 단순하게 말하자면, 일반적인 절차적인 모양새로 코드를 짜면서(가독성 상승) 비동기를 구현할 수 있다. '코루틴'이라는 단어 자체의 의미는 '상호작용하는 루틴'이라는 뜻인데, 일반적인 함수가 서브루틴&lt;code&gt;subroutine&lt;/code&gt; 개념인 것과 대조적이다. 이런 코루틴을 이해하려면 먼저 제네레이터&lt;code&gt;generator&lt;/code&gt; 개념에 대해서 알아야 한다. 다음을 참조한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/qodot/wiki/wiki/Python-Generator"&gt;Python Generator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;제네레이터를 이용하면 두개의 함수가 서로 메세지를 주고 받으면서 코루틴&lt;code&gt;coroutine&lt;/code&gt;으로서 동작할 수 있다는 것을 확인했다. 이것에 이어서, &lt;code&gt;asyncio&lt;/code&gt;가 이 제네레이터와 코루틴 개념을 이용해서 이벤트 드리븐&lt;code&gt;event-driven&lt;/code&gt;으로 비동기 작업을 처리할 수 있는지 알아보자.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Asyncio&lt;/h2&gt;
&lt;h3&gt;Event Loop &amp;amp; Message Queue&lt;/h3&gt;
&lt;p&gt;코드가 이벤트 드리븐으로 동작하려면 이벤트를 받아줄 이벤트 루프&lt;code&gt;event loop&lt;/code&gt;와 메세지 큐&lt;code&gt;message queue&lt;/code&gt;가 필요하다. 파이썬의 &lt;code&gt;asyncio&lt;/code&gt;에서 바로 이 부분을 제공해준다. 이벤트 루프를 만들고, 원하는 코루틴을 메세지 큐에 넣어 스케쥴링 하는 코드를 살펴보자.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;asyncio&lt;/span&gt;

&lt;span class="nd"&gt;@asyncio.coroutine&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;some_coroutine&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;asyncio&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_event_loop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run_until_complete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;some_coroutine&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;@asyncio.coroutine&lt;/code&gt; 데코레이터는 이 함수가 코루틴임을 알려준다. 코루틴은 그냥 제네레이터라고 봐도 거의 무방하다. 일반 제네레이터는 함수를 실행하면 제네레이터 객채가 생성되고 수동으로 &lt;code&gt;next()&lt;/code&gt;를 호출해줘야 시작되는데, 이것을 자동화하여 함수를 실행하면 바로 내부 로직이 실행될 수 있도록 해준다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;some_coroutine&lt;/code&gt;은 메세지 큐에 잘 넣었지만, &lt;code&gt;some_coroutine&lt;/code&gt; 내부에서도 다른 코루틴을 메세지 큐에 계속해서 넣고 싶을 수 있다. 이럴 때 &lt;code&gt;yield from&lt;/code&gt; 문법과 &lt;code&gt;asyncio&lt;/code&gt;의 &lt;code&gt;Task&lt;/code&gt; 클래스를 이용한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@asyncio.coroutine&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;another_coroutine&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="nd"&gt;@asyncio.coroutine&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;some_coroutine&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;yield from&lt;/span&gt; &lt;span class="n"&gt;asyncio&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Task&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;another_coroutine&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이런 식으로 간단하게 코루틴을 스케쥴링 할 수 있다.&lt;/p&gt;
&lt;h3&gt;비동기 처리&lt;/h3&gt;
&lt;p&gt;메세지 큐에 넣은 코루틴은 이벤트 루프에 의해 백그라운드에서 실행될 것이다. 이 실행 결과를 받을 수 있어야 비로소 비동기 처리를 한다고 말할 수 있을 것이다. 콜백 패턴에서는 비동기 작업의 실행 결과를 얻기 위해서 콜백 함수를 등록했다. &lt;code&gt;asyncio&lt;/code&gt;에서는 다음과 같이 처리한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;yield from&lt;/span&gt; &lt;span class="n"&gt;asyncio&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Task&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;another_coroutine&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;오잉? 뭐야 이거 비동기 맞아??&lt;/strong&gt; 네 맞습니다. &lt;strong&gt;그냥 평범한 synchronous 코드 같은데?&lt;/strong&gt; 네 그래서 좋은겁니다. &lt;code&gt;yield from&lt;/code&gt;은 쉽게 말하면 '이 작업이 끝날 때 까지 기다린다'의 의미입니다. &lt;strong&gt;그럼 비동기가 아니지 않나?&lt;/strong&gt; 그 기다리는 시간동안 다른 작업을 처리할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;결론&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;asyncio&lt;/code&gt;를 이용하면 &lt;code&gt;callback/promise&lt;/code&gt; 패턴 같은 스타일이 아닌, 평범하게 절차적/동기적 스타일로 코드를 작성하면서, (thread 같은 방법에 비해서) 리소스 대비 성능이 뛰어난 이벤트 드리븐 방식으로 비동기 작업을 처리할 수 있다.&lt;/p&gt;
&lt;p&gt;자바스크립트에서도 제네레이터를 비롯하여 파이썬의 &lt;code&gt;asyncio&lt;/code&gt;가 제공하는 기능을 거의 동일하게(진짜 똑같다 ㅋㅋ) 제공하고 있다. 이런 추세로 봐서, 제네레이터와 코루틴 개념을 이용한 비동기 처리는 지금도 그렇지만 앞으로는 더욱 일반적이고 중요한 개념이 될 것 같다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;참고한 사이트&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://b.ssut.me/58"&gt;Python 3, asyncio와 놀아보기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.flowdas.com/blog/asyncio-python-tulip/"&gt;asyncio - Python Tulip&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.pycon.kr/2014/program/4"&gt;PyCon 2014 - Python 3.4:AsyncIO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;http://stackoverflow.com/questions/27076577/yield-from-coroutine-vs-yield-from-task&lt;/li&gt;
&lt;li&gt;http://stackoverflow.com/questions/29819151/what-should-i-decorate-with-asyncio-coroutine-for-async-operations&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;&lt;code&gt;GIL&lt;/code&gt;까지 설명하기에는 너무 일이 커지는 느낌이 들어서 링크로 대체한다. 1) &lt;a href="https://yinjae.wordpress.com/2012/04/02/python-thread/"&gt;Python에서 thread를 사용하지 마세요?&lt;/a&gt; 2) &lt;a href="highthroughput.org/wp/cb-1136/"&gt;파이썬 GIL 깊숙히! (上)&lt;/a&gt; 3) &lt;a href="http://highthroughput.org/wp/cb-1146/"&gt;파이썬 GIL 깊숙히! (상) 에 대한 몇 가지 변명&lt;/a&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;&lt;code&gt;promise&lt;/code&gt;패턴을 이용해 극복한 부분도 많다.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="python"></category><category term="asyncio"></category></entry><entry><title>Python Generator</title><link href="/Python-Generator.html" rel="alternate"></link><published>2016-03-06T00:00:00+00:00</published><author><name></name></author><id>tag:,2016-03-06:Python-Generator.html</id><summary type="html">&lt;p&gt;파이썬에서 제네레이터는 이터레이터&lt;code&gt;iterator&lt;/code&gt;의 확장 개념이라고 볼 수 있다. 이터레이터는 '순회 가능한&lt;code&gt;iterable&lt;/code&gt;' 객체로서, 실제로는 &lt;code&gt;__next__&lt;/code&gt; 함수가 구현되어 있는 객체라고 보면 된다. 예를 들면, &lt;code&gt;for&lt;/code&gt;문을 수행할 때, 내부적으로 &lt;code&gt;__next__&lt;/code&gt; 함수를 호출해서 동작한다. 제네레이터는 이터레이터의 확장 개념으로, &lt;code&gt;__next__&lt;/code&gt; 함수의 리턴값은 &lt;code&gt;yield&lt;/code&gt; 구문값으로 대신한다. 즉, &lt;code&gt;yield&lt;/code&gt; 구문이 포함된 함수를 제네레이터라고 한다.&lt;/p&gt;
&lt;p&gt;다음은 파이썬의 &lt;code&gt;range(n)&lt;/code&gt; 함수를 제네레이터를 이용해 구현해 본 것이다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;custom_range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
        &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이 제네레이터를 실행해보면,&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;custom_range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;generator&lt;/span&gt; &lt;span class="nb"&gt;object&lt;/span&gt; &lt;span class="n"&gt;custom_range&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="mh"&gt;0x1096d0870&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;custom_range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;__next__&lt;/code&gt; 함수가 호출되면 다음 &lt;code&gt;yield&lt;/code&gt;까지 진행되고 &lt;code&gt;yield&lt;/code&gt;값이 반환된다. 이 때, 일반적인 서브루틴 함수처럼 &lt;code&gt;return&lt;/code&gt;되면서 스택 메모리에서 사라지는 것이 아니라, 컨텍스트가 유지된 채로 제어권만 넘겨주는(양보&lt;code&gt;yield&lt;/code&gt;하는) 것이다.&lt;/p&gt;
&lt;p&gt;이 때, 위의 &lt;code&gt;yield c&lt;/code&gt; 구문의 리턴 값은 &lt;code&gt;None&lt;/code&gt;이다. 원래 &lt;code&gt;yield&lt;/code&gt;문은 항상 &lt;code&gt;None&lt;/code&gt;을 리턴하는데,&lt;code&gt;send&lt;/code&gt; 함수를 이용해서 메인 루틴에서 제네레이터 루틴으로 값을 주입하면, &lt;code&gt;yield&lt;/code&gt;문의 리턴값을 변경 할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;gene&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nb"&gt;input&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;output&amp;#39;&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;실행해보면,&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gene&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="s1"&gt;&amp;#39;output&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="bp"&gt;None&lt;/span&gt;
&lt;span class="s1"&gt;&amp;#39;output&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;input&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;input&lt;/span&gt;
&lt;span class="s1"&gt;&amp;#39;output&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;hello&lt;/span&gt;
&lt;span class="s1"&gt;&amp;#39;output&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이렇게 &lt;code&gt;yield&lt;/code&gt; 구문을 기준으로 메인 루틴과 제네레이터 루틴이 서로 메세지를 주고 받으며 상호작용할 수 있다. 이렇게 프로그래머가 직접 제어권을 수동으로 설정할 수 있기 때문에, 직접 루틴을 제어할 수 없는 쓰레드 프로그래밍을 대체할 수 있는 비동기 프로그래밍에 매우 중요하게 사용되기도 한다.&lt;/p&gt;</summary><category term="python"></category></entry><entry><title>Python으로 텔레그램 봇 만들기</title><link href="/Python%EC%9C%BC%EB%A1%9C-%ED%85%94%EB%A0%88%EA%B7%B8%EB%9E%A8-%EB%B4%87-%EB%A7%8C%EB%93%A4%EA%B8%B0.html" rel="alternate"></link><published>2016-03-06T00:00:00+00:00</published><author><name></name></author><id>tag:,2016-03-06:Python으로-텔레그램-봇-만들기.html</id><summary type="html">&lt;h2&gt;개요 및 기획&lt;/h2&gt;
&lt;p&gt;회사에 있는 하루 중 가장 힘든 시간은 바로 점심을 뭘 먹을지 결정하는 순간이다. 사실 누구든 아무거나 먹어도 상관 없는데 아무도 결정하지 못하는 상황을 자주 마주치게 된다. 그래서 나는 우리 대신 빠른 결정을 내려줄 무언가가 필요하다고 생각했다.&lt;/p&gt;
&lt;p&gt;식당을 등록/제거하고, 등록된 식당을 조회하고, 등록된 식당 중에 하나를 랜덤으로 뽑아줄 기능이 필요했다. 그런데 이렇게 간단한 기능을 웹서비스로 구현하는 것은 불필요하게 큰 작업이라는 생각이 들었고, 마침 평소에 궁금해 했던 텔레그램 봇 API를 이용해서 만들면 적절하겠다라는 생각을 했다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Bot Token 얻기&lt;/h2&gt;
&lt;p&gt;텔레그램을 pc나 스마트 기기에 설치하고, 친구 검색창에 &lt;code&gt;@BotFather&lt;/code&gt;를 입력해서 봇 파더와 대화를 시작한다. 봇 파더에게 &lt;code&gt;/start&lt;/code&gt;, &lt;code&gt;/newbot&lt;/code&gt; 명령어를 차례로 입력하고, 프로젝트 이름과 봇의 이름을 입력하면 access token을 준다. 이것을 잘 저장해놓고 있자.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Telepot 설치&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://core.telegram.org/bots/api"&gt;텔레그램의 공식 봇 API 문서&lt;/a&gt;를 봐도 되지만, 더 간단한 방법이 있다. 봇 API를 wrapping한 telepot(&lt;a href="https://github.com/nickoala/telepot"&gt;github&lt;/a&gt;)을 쓰면 된다.&lt;/p&gt;
&lt;p&gt;적절히 python 환경을 구성한 뒤, telepot을 설치한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip install telepot
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;기본적인 사용법은 telepot github 페이지에 잘 정리되어 있다. 그 중에서도 더 기본적인 기능만 소개해보면,&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 봇 생성&lt;/span&gt;
&lt;span class="n"&gt;bot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;telepot&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;YOUR_ACCESS_TOKEN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# 메세지 수신 대기 (busy waiting)&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;
&lt;span class="n"&gt;bot&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;notifyOnMessage&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;callback_function_to_handle_message&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# 메세지 발신&lt;/span&gt;
&lt;span class="n"&gt;bot&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sendMessage&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sending_message&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;메세지 발신시의 &lt;code&gt;target&lt;/code&gt;은 수신 메세지에 들어있는 &lt;code&gt;chat_id&lt;/code&gt;이다. (수신된 메세지를 출력해 보면 구조를 자세히 알 수 있다.)&lt;/p&gt;
&lt;p&gt;이를 잘 조합해서 간단하게 필요한 기능을 구현할 수 있다. 커스텀 키보드를 유저에게 노출시켜서 편리한 UX을 제공할 수도 있으니, 이용해 보면 좋을 것 같다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;SQLAlchemy&lt;/h2&gt;
&lt;h3&gt;설치&lt;/h3&gt;
&lt;p&gt;등록한 음식점을 데이터베이스에 저장해 놓아야 다음에 다시 등록하는 일 없이 사용할 수 있기 때문에, &lt;code&gt;sqlalchemy&lt;/code&gt;와 &lt;code&gt;sqlite&lt;/code&gt;를 이용해서 간단하게 데이터베이스를 구현해 보자.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sqlalchemy&lt;/code&gt;에 대한 기본적인 소개와 튜토리얼은 &lt;a href="http://haruair.com/blog/1682"&gt;Haruair님의 SQLAlchemy 시작하기&lt;/a&gt;에 잘 정리되어 있으니 참고바란다.&lt;/p&gt;
&lt;p&gt;다음 명령어로 설치한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip install sqlalchemy
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Scheme 생성&lt;/h3&gt;
&lt;p&gt;다음은 데이터베이스 연결을 수행하고, 식당의 테이블 정보를 담고있는 &lt;code&gt;sqlalchemy&lt;/code&gt; 모델 정보가 담겨있는 &lt;code&gt;db.py&lt;/code&gt; 파일이다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;datetime&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;datetime&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sqlalchemy&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;create_engine&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sqlalchemy&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Column&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DateTime&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sqlalchemy.orm&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;sessionmaker&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sqlalchemy.ext.declarative&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;declarative_base&lt;/span&gt;


&lt;span class="c1"&gt;# 데이터베이스 연결 및 세션 취득&lt;/span&gt;
&lt;span class="n"&gt;engine&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;create_engine&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;sqlite:///db.sqlite3&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;echo&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sessionmaker&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;engine&lt;/span&gt;&lt;span class="p"&gt;)()&lt;/span&gt; &lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;declarative_base&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;


&lt;span class="c1"&gt;# 식당 테이블&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Restaurant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;__tablename__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;restaurants&amp;#39;&lt;/span&gt;

    &lt;span class="nb"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Column&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;primary_key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Column&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;created_at&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Column&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DateTime&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;datetime&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;now&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;updated_at&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Column&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DateTime&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;datetime&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;now&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;onupdate&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;datetime&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;now&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위의 &lt;code&gt;session&lt;/code&gt; 변수를 통해 데이터베이스에 접속해서 쿼리를 실행할 수 있다.&lt;/p&gt;
&lt;h3&gt;Migration&lt;/h3&gt;
&lt;p&gt;이제 저 python class를 이용해  실제 데이터베이스의 테이블로 만들어줘야 하는데, 여러가지 방법이 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;직접 데이터베이스에 접속해서 &lt;code&gt;create table&lt;/code&gt; 쿼리를 날린다.&lt;/li&gt;
&lt;li&gt;sqlalchemy의 &lt;code&gt;Base.metadata.create_all(engine)&lt;/code&gt;를 이용해서 자동으로 테이블을 생성한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alembic&lt;/code&gt;을 이용해서 마이그레이션 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1번은 너무 귀찮고, 2번의 경우 테이블 생성은 되지만 테이블 변경은 자동으로 되지 않는 문제가 있어서(프로젝트가 단순해서 변경할 일이 없다면 문제 없겠지만) 3번을 선택했다. &lt;code&gt;alembic&lt;/code&gt;은 &lt;code&gt;sqlalchemy&lt;/code&gt;를 위한 마이그레이션 툴이고, 이전에 작성했던 &lt;a href="http://qodot.github.io/Alembic-%ED%80%B5-%EA%B0%80%EC%9D%B4%EB%93%9C.html"&gt;Alembic 퀵 가이드&lt;/a&gt;에서 간단하게 소개한 적이 있다. 참고하길 바란다.&lt;/p&gt;
&lt;h3&gt;사용&lt;/h3&gt;
&lt;p&gt;1, 2, 3번 중 하나를 선택해서 테이블 스키마를 생성했다면, 이제 데이터베이스에 접속해서 쿼리를 날려볼 차례인데, 여기서는 이 프로젝트에서 사용한 기본적인 &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt; 동작의 예시를 소개해 본다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 식당 테이블의 모든 row 조회&lt;/span&gt;
&lt;span class="n"&gt;restaurants&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Restaurant&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;all&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;# 식당 테이블의 모든 row 갯수 조회&lt;/span&gt;
&lt;span class="n"&gt;restaurants_count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Restaurant&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;# 새 식당 등록&lt;/span&gt;
&lt;span class="n"&gt;restaurant&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Restaurant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;restaurant&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;commit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;# 특정 이름을 가진 식당 하나를 제거&lt;/span&gt;
&lt;span class="n"&gt;restaurant&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Restaurant&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Restaurant&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;restaurant&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;commit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;개선점&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;telepot&lt;/code&gt;과 &lt;code&gt;sqlalchemy&lt;/code&gt;를 이용해서 텔레그램 봇을 만들 수 있다. 그런데 실제로 봇을 운영하려면 python 스크립트를 리눅스 데몬이나 서비스로 띄우는 방법에 대한 고려가 되어야 한다. 그리고 이벤트 listen을 담당하는 부분이 busy waiting 방식으로 구현되어 있는데 &lt;code&gt;asyncio&lt;/code&gt;를 이용한 비동기 방식으로 구현하는 것이 더 좋을 것이다. 특히 두 번 째 부분은 공부가 많이 필요한 부분이라... 따로 포스트를 작성하면서 정리해야 겠다.&lt;/p&gt;</summary><category term="python"></category><category term="telegrambot"></category></entry><entry><title>Pyenv, Virtualenv, Autoenv로 Python 환경 설정하기</title><link href="/Pyenv-Virtualenv-Autoenv%EB%A1%9C-Python-%ED%99%98%EA%B2%BD-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0.html" rel="alternate"></link><published>2016-01-30T00:00:00+00:00</published><author><name></name></author><id>tag:,2016-01-30:Pyenv-Virtualenv-Autoenv로-Python-환경-설정하기.html</id><summary type="html">&lt;h2&gt;개요&lt;/h2&gt;
&lt;p&gt;이전의 파이썬의 가상환경은 &lt;code&gt;virtualenv&lt;/code&gt;를 이용해서 관리했었다. 그러나 그것만으로는 다양한 파이썬 버전을 관리할 수가 없었기 때문에, (Ruby의 &lt;code&gt;rbenv&lt;/code&gt;처럼)이 문제를 해결하기 위한 도구가 필요했고 그게 바로 &lt;code&gt;pyenv&lt;/code&gt;이다. &lt;code&gt;virtualenv&lt;/code&gt;의 기능도 &lt;code&gt;pyenv&lt;/code&gt;의 플러그인(&lt;code&gt;pyenv-virtualenv&lt;/code&gt;)을 이용하면 동일하게 사용할 수 있기 때문에 &lt;code&gt;pyenv&lt;/code&gt;를 안 쓸 이유가 없다.&lt;/p&gt;
&lt;p&gt;마지막에는 파이썬과는 관련이 없지만, 환경 설정을 더 편하게 해주는 &lt;code&gt;autoenv&lt;/code&gt;도 소개하겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Pyenv&lt;/h2&gt;
&lt;p&gt;사실 설치부터 사용법까지 대부분의 가이드가 &lt;a href="https://github.com/yyuu/pyenv"&gt;개발자의 Github&lt;/a&gt;에 자세하게 나와있다. 필요하면 이곳을 참조하기 바란다. 여기서는 바로 시작할 수 있도록 핵심만 간단히 다루겠다.&lt;/p&gt;
&lt;h3&gt;설치&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;homebrew&lt;/code&gt;를 통해 설치&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;brew install pyenv

&lt;span class="c1"&gt;# .zshrc .bashrc .bash_profile 등에 다음을 추가&lt;/span&gt;
&lt;span class="nb"&gt;eval&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;pyenv init -&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;소스를 직접 다운로드해서 설치&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone https://github.com/yyuu/pyenv.git ~/.pyenv

&lt;span class="c1"&gt;# .zshrc .bashrc .bash_profile 등에 다음을 추가&lt;/span&gt;
&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;PYENV_ROOT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$HOME&lt;/span&gt;&lt;span class="s2"&gt;/.pyenv&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$PYENV_ROOT&lt;/span&gt;&lt;span class="s2"&gt;/bin:&lt;/span&gt;&lt;span class="nv"&gt;$PATH&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;eval&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;pyenv init -&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;사용법&lt;/h3&gt;
&lt;p&gt;설치 가능한 파이썬 버전 확인&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pyenv install --list
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;파이썬 설치&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pyenv install &amp;lt;version&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;shim 바이너리 리빌드 (바이너리 설치 후에 반드시 해줘야 함)&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python rehash
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;현재 사용중인 Python version 확인&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pyenv version
&amp;gt;&amp;gt; 3.5.0 &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt; by /Users/user/.pyenv/version&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;설치된 파이썬 버전 확인&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pyenv versions
&amp;gt;&amp;gt; system
* 3.5.0 &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt; by /Users/user/.pyenv/version&lt;span class="o"&gt;)&lt;/span&gt;
3.5.1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Pyenv-virtualenv&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;pyenv&lt;/code&gt; 개발자가 만든 플러그인이다. 역시 &lt;a href="https://github.com/yyuu/pyenv-virtualenv"&gt;Github&lt;/a&gt;에 설치법과 사용법이 자세히 나와 있다.&lt;/p&gt;
&lt;h3&gt;설치&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;homebrew&lt;/code&gt;를 통해 설치&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;brew install pyenv-virtualenv

&lt;span class="c1"&gt;# .zshrc .bashrc .bash_profile 중 하나에&lt;/span&gt;
&lt;span class="nb"&gt;eval&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;pyenv virtualenv-init -&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;소스를 직접 다운로드해서 설치&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone https://github.com/yyuu/pyenv-virtualenv.git ~/.pyenv/plugins/pyenv-virtualenv

&lt;span class="c1"&gt;# .zshrc .bashrc .bash_profile 중 하나에&lt;/span&gt;
&lt;span class="nb"&gt;eval&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;pyenv virtualenv-init -&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;사용법&lt;/h3&gt;
&lt;p&gt;파이선 버전과 함께 새로운 가상환경 생성&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pyenv virtualenv &amp;lt;python_version&amp;gt; &amp;lt;virtualenv_name&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;가상환경 활성화&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pyenv activate &amp;lt;virtualenv_name&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;가상환경 해제&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pyenv deactivate
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Autoenv&lt;/h2&gt;
&lt;h3&gt;개요&lt;/h3&gt;
&lt;p&gt;디렉토리 기반의 환경 설정 도구. 디렉토리를 이동할 때마다 해당 디렉토리에 &lt;code&gt;.env&lt;/code&gt;파일 안에 있는 스크립트를 실행한다. 자세한 내용은 &lt;a href="https://github.com/kennethreitz/autoenv"&gt;Github&lt;/a&gt;을 참조한다.&lt;/p&gt;
&lt;h3&gt;설치&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;brew install autoenv

&lt;span class="c1"&gt;# .zshrc .bashrc .bash_profile 중 하나에&lt;/span&gt;
&lt;span class="nb"&gt;source&lt;/span&gt; /usr/local/opt/autoenv/activate.sh
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;사용&lt;/h3&gt;
&lt;p&gt;원하는 디렉토리에 원하는 스크립트로 &lt;code&gt;.env&lt;/code&gt; 파일을 작성한다. 예를 들면,&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 디렉토리에 진입하면 특정 Python 가상환경을 활성화한다.&lt;/span&gt;
pyenv activate &amp;lt;virtualenv_name&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;참조한 사이트&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://dobest.io/how-to-set-python-dev-env/"&gt;pyenv + virtualenv + autoenv 를 통한 Python 개발 환경 구축하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;rehash를 자동화하고 싶다면 다음 플러그인을 참조한다. https://github.com/yyuu/pyenv-pip-rehash&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="pyenv"></category><category term="virtualenv"></category><category term="autoenv"></category></entry><entry><title>Alembic Quickstart</title><link href="/Alembic-Quickstart.html" rel="alternate"></link><published>2015-11-25T00:00:00+00:00</published><author><name></name></author><id>tag:,2015-11-25:Alembic-Quickstart.html</id><summary type="html">&lt;h2&gt;개요&lt;/h2&gt;
&lt;p&gt;Rails나 Django 같은 모던 웹 프레임워크의 ORM에서는, 반복되는 DB 스키마 변경을 수월하게 진행 할 수 있도록 전용 마이그레이션 툴이 ORM에 내장되어 있다. 그러나 SQLAlchemy에서는 기본적으로 테이블의 생성은 가능하나, 생성된 테이블의 스키마 변경은 지원하지 않는데, 이를 수월하게 만들어 주는 툴이 바로 Alembic이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;설치&lt;/h2&gt;
&lt;p&gt;그냥 &lt;code&gt;pip&lt;/code&gt;으로 설치한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip install alembic
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;프로젝트 생성&lt;/h2&gt;
&lt;p&gt;원하는 디렉토리에서&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;alembic init alembic
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;을 실행하면 다음과 같은 디렉토리 구조가 생긴다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;yourproject/
    alembic/
        env.py
        README
        script.py.mako
        versions/
            3512b954651e_add_account.py
            2b1ae634e5cd_add_order_id.py
            3adcc9a56557_rename_username_field.py
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;yourproject: root 디렉토리&lt;/li&gt;
&lt;li&gt;env.py: Alembic이 실행될 때 환경을 설정하기 위해 먼저 실행되는 설정용 스크립트&lt;/li&gt;
&lt;li&gt;versions: 실제 &lt;code&gt;revision&lt;/code&gt;&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;가 순차적으로 쌓이는 디렉토리&lt;/li&gt;
&lt;li&gt;alembic.ini: 설정 변수들이 저장되는 파일. &lt;code&gt;env.py&lt;/code&gt;에서 이 파일을 읽어서 설정값을 채움&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;기본 환경 설정&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;alembic.ini&lt;/code&gt; 파일을 열어서 &lt;code&gt;sqlalchemy.url&lt;/code&gt; 변수에 원하는 데이터베이스의 URL을 입력한다. 만약 로컬, 개발, 상용 등의 환경 분리가 필요하다면 아예 ini 파일을 따로 만들어서 Alembic 명령어를 &lt;code&gt;-c&lt;/code&gt; 옵션과 함께 줄 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;alembic -c development.ini upgrade head
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;혹은 하나의 파일 내부에 대괄호를 이용해서 이름을 붙여 나눌 수도 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;development&lt;span class="o"&gt;]&lt;/span&gt;
sqlalchemy.url &lt;span class="o"&gt;=&lt;/span&gt; dev_db_url

&lt;span class="o"&gt;[&lt;/span&gt;production&lt;span class="o"&gt;]&lt;/span&gt;
sqlalchemy.url &lt;span class="o"&gt;=&lt;/span&gt; prod_db_url

alembic --name development upgrade head
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Revision 생성&lt;/h2&gt;
&lt;p&gt;적용을 원하는 Alembic 환경의 root 디렉토리로 이동하고, &lt;code&gt;revision&lt;/code&gt;의 이름을 지정하여 생성한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;alembic revision -m &lt;span class="s1"&gt;&amp;#39;create some table&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;versions&lt;/code&gt; 디렉토리에 생성된 스크립트를 보면 &lt;code&gt;upgrade&lt;/code&gt;와 &lt;code&gt;downgrade&lt;/code&gt; 메소드가 있는데, 이곳에 원하는 로직을 채워 넣으면 된다.&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt; 로직은 SQLAlchemy의 객체와 메소드를 이용한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;upgrade&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create_table&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="s1"&gt;&amp;#39;account&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;sa&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Column&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sa&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;primary_key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="n"&gt;sa&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Column&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sa&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;nullable&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="n"&gt;sa&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Column&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;description&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sa&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Unicode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;downgrade&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;drop_table&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;account&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;물론 SQLAlchemy가 raw SQL을 지원하므로 이에 맞춰 직접 SQL을 작성할 수도 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;생성된 Revision 적용&lt;/h2&gt;
&lt;p&gt;적용을 원하는 Alembic 환경의 root 디렉토리로 이동하고, 명령어를 입력한다. 다음의 명령어를 사용하면 자유자재로 스키마 버전을 왔다갔다 할 수 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;가장 최신의 마이그레이션 스크립트까지 순차 적용&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;alembic upgrade head
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;현재 마이그레이션 버전으로 부터 한단계 상위의 스크립트만 적용&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;alembic upgrade +1
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;원하는 단계만큼 롤백&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;alembic downgrade -1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Revision 자동 생성&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;upgrade&lt;/code&gt;, &lt;code&gt;downgrade&lt;/code&gt; 메소드를 직접 구현하지 않고, 변경한 SQLAlchemy 모델(&lt;code&gt;Base&lt;/code&gt;를 상속받은 클래스)을 자동으로 감지하여 마이그레이션 스크립트를 생성 할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;alembic revision --autogenerate -m &lt;span class="s1"&gt;&amp;#39;some messages&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;하지만 먼저, 이 기능을 이용하려면 &lt;code&gt;env.py&lt;/code&gt; 파일을 이용해서 Alembic이 SQLAlchemy의 변경 사항을 자동으로 감지할 수 있도록 설정해 주어야 한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;env.py&lt;/code&gt; 파일을 열고 다음과 같이 입력 혹은 수정한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# SQLAlchemy의 모델 메타데이터를 가져옴&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;app.database&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;
&lt;span class="n"&gt;target_metadata&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;metadata&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;run_migrations_online&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;engine&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;engine_from_config&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_section&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;config_ini_section&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;prefix&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;sqlalchemy.&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;poolclass&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;pool&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NullPool&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;engine&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;connection&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;configure&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;connection&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;connection&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="c1"&gt;# 가져온 메타데이터를 넣는 부분&lt;/span&gt;
            &lt;span class="n"&gt;target_metadata&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;target_metadata&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin_transaction&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
            &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run_migrations&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;--autogenerate&lt;/code&gt; 옵션이 모든 변화를 전부 감지 할 수 있는 것은 아니다. 따라서 자동으로 &lt;code&gt;revision&lt;/code&gt;을 생성했다면, 꼭 한 번 파일을 열어서 의도한대로 스크립트가 생성되었는지 점검하는 것이 좋다. 이와 관련해서 자세한 내용은 공식 문서&lt;a href="http://alembic.zzzcomputing.com/en/latest/autogenerate.html#what-does-autogenerate-detect-and-what-does-it-not-detect"&gt;What Does Autogenerate Detec&lt;/a&gt;를 참조하길 바란다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;각각의 Migration Script를 의미한다.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;&lt;code&gt;upgrade&lt;/code&gt;에는 현재 변화를 원하는 로직을, &lt;code&gt;downgrade&lt;/code&gt;에는 롤백용 로직을 넣으면 된다.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="alembic"></category><category term="sqlalchemy"></category></entry><entry><title>SQLAlchemy Quickstart</title><link href="/SQLAlchemy-Quickstart.html" rel="alternate"></link><published>2015-11-20T00:00:00+00:00</published><author><name></name></author><id>tag:,2015-11-20:SQLAlchemy-Quickstart.html</id><summary type="html">&lt;p&gt;SQLAlchemy를 사용하기 위한 기본적인 설정을 하는 방법을 요약해본다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;설치&lt;/h2&gt;
&lt;p&gt;그냥 &lt;code&gt;pip&lt;/code&gt;으로 설치하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;pip&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;sqlalchemy&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;설정&lt;/h2&gt;
&lt;h3&gt;접속 설정&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sqlalchemy&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;create_engine&lt;/span&gt;

&lt;span class="n"&gt;URL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;postgresql://&amp;lt;username&amp;gt;:&amp;lt;password@&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/&amp;lt;dbname&amp;gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;engine&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;create_engine&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;URL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;echo&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;간단하게 &lt;code&gt;engine.execute('SELECT 1').scalar()&lt;/code&gt; 같은 코드를 실행해보면 접속을 테스트해 볼 수 있다.&lt;/p&gt;
&lt;h3&gt;세션 팩토리 설정&lt;/h3&gt;
&lt;p&gt;데이터베이스의 커넥션을 필요할 때마다 리턴해 줄 세션 팩토리가 필요하다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sqlalchemy.orm&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;sessionmaker&lt;/span&gt;

&lt;span class="n"&gt;Session&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sessionmaker&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;engine&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위의 &lt;code&gt;Session&lt;/code&gt;이 세션 팩토리이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;ORM 사용&lt;/h2&gt;
&lt;h3&gt;선언&lt;/h3&gt;
&lt;p&gt;raw SQL만 쓸거면 SQLAlchemy를 쓸 이유가 없다. ORM을 사용하는 방법을 알아보자.&lt;/p&gt;
&lt;p&gt;기본적으로 &lt;code&gt;Base&lt;/code&gt; 클래스를 상속 받은 클래스가 테이블이 되고, 그 클래스의 필드가 컬럼이 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sqlalchemy.ext.declarative&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;declarative_base&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sqlalchemy&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Column&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;

&lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;declarative_base&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Table1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;__tablename__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;table1&amp;#39;&lt;/span&gt;

    &lt;span class="n"&gt;column1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Column&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;column2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Column&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이건 단순히 선언했을 뿐이고, 실제로 DBMS에 스키마가 생성된건 아니다. &lt;code&gt;Base.metadata.create_all(engine)&lt;/code&gt;를 실행해야 선언된 클래스가 DBMS로 반영된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;create_all&lt;/code&gt;의 문제점은 테이블의 생성만 해준다는 것이다. 즉 컬럼의 추가나 삭제, 속성 변경 같은 것은 반영되지 않는다. 이 작업을 쉽게(Django, Rails 같이)하려면 Alembic이라는 프로젝트를 따로 사용해야 한다. 필요하면 다음 페이지를 참조한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/qodot/wiki/wiki/Python-Alembic-Quickstart"&gt;Alembic Quickstart&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;사용&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 조회&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Session&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;table1_object&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Table1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Table1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column1&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="err"&gt;‘&lt;/span&gt;&lt;span class="n"&gt;something&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;column2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;table1_object&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column2&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;commit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;# 생성&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Session&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;table1_object2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Table1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;table1_object2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;commit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;# 업데이트&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Session&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;table1_object&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Table1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Table1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column1&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="err"&gt;‘&lt;/span&gt;&lt;span class="n"&gt;something&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;table1_object&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;new_value&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;commit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;# 삭제&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Session&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;table1_object&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Table1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Table1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;column1&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="err"&gt;‘&lt;/span&gt;&lt;span class="n"&gt;something&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;table1_object&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;commit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="sqlalchemy"></category></entry><entry><title>Django 설정을 환경 변수로 관리하기</title><link href="/Django-%EC%84%A4%EC%A0%95%EC%9D%84-%ED%99%98%EA%B2%BD-%EB%B3%80%EC%88%98%EB%A1%9C-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0.html" rel="alternate"></link><published>2015-07-30T00:00:00+00:00</published><author><name></name></author><id>tag:,2015-07-30:Django-설정을-환경-변수로-관리하기.html</id><summary type="html">&lt;h2&gt;개요&lt;/h2&gt;
&lt;p&gt;설정 정보를 다루다 보면 코드에 그대로 적어서는 안되는 정보들이 있다. 예를 들어 Github의 public 계정을 사용할 경우, 불특정 다수가 서비스의 상용 데이터베이스의 접속 정보를 알아서는 안될 것이다.&lt;/p&gt;
&lt;p&gt;그래서, 간단하게 django 설정 정보를 환경 변수로 등록해서 repository에 노출되지 않도록 해보자. (SECRET_KEY를 예로 들겠음) 만약 virtualenv를 쓰고 있지 않다면 상당히 간단하다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Virtualenv를 사용하지 않는 경우&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;.bashrc&lt;/code&gt;, &lt;code&gt;.bash_profile&lt;/code&gt;, &lt;code&gt;.zshrc&lt;/code&gt;에 환경 변수를 등록한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;SECRET_KEY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;my_secret_key&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Django의 설정 변수를 다음과 같이 바꾼다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="n"&gt;SECRET_KEY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;environ&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;SECRET_KEY&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Virtualenv를 사용하는 경우&lt;/h2&gt;
&lt;p&gt;해당 프로젝트가 이용하는 가상환경 디렉토리로 이동한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; ~/.virtualenvs/myproject/
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;bin&lt;/code&gt; 디렉터리로 이동해서 &lt;code&gt;postactivate&lt;/code&gt; 파일을 편집기로 연다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; bin
vi postactivate
&lt;span class="c1"&gt;# postactivate : 가상환경이 실행되고 바로 다음에 실행할 shell script&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;등록할 환경 변수를 입력한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;SECRET_KEY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;my_secret_key&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;postdeactivate&lt;/code&gt; 파일을 편집기로 연다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vi postdeactivate
&lt;span class="c1"&gt;# postdeactivate : 가상환경에서 빠져 나오고 바로 다음에 실행할 shell script&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;앞에서 등록했던 환경변수를 해제한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;unset&lt;/span&gt; SECRET_KEY
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Django의 설정 변수를 다음과 같이 바꾼다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="n"&gt;SECRET_KEY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;environ&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;SECRET_KEY&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;PS&lt;/h2&gt;
&lt;p&gt;전에 작성했던 Django 환경 설정 분리에서 &lt;code&gt;DJANGO_SETTINGS_MODULE&lt;/code&gt;를 사용했었다. 이 값도 &lt;code&gt;postactivate&lt;/code&gt;와 &lt;code&gt;postdeactivate&lt;/code&gt;에 등록해서 관리가 가능하다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4&gt;참고한 페이지&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/15209978/where-to-store-secret-keys-django"&gt;Where to store secret keys DJANGO&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="django"></category></entry><entry><title>Django settings.py 환경 분리</title><link href="/Django-settings.py-%ED%99%98%EA%B2%BD-%EB%B6%84%EB%A6%AC.html" rel="alternate"></link><published>2015-07-29T00:00:00+00:00</published><author><name></name></author><id>tag:,2015-07-29:Django-settings.py-환경-분리.html</id><summary type="html">&lt;h2&gt;개요&lt;/h2&gt;
&lt;p&gt;애플리케이션을 배포하게 되면, 장비에 따라 필요한 라이브러리, 데이터베이스 정보 등 설정 정보를 다르게 가져가야 한다. Django 프로젝트를 생성하면 기본적으로 1개의 &lt;code&gt;settings.py&lt;/code&gt;가 있는데, 설정 정보를 따로 가져가기 위해서는 파일을 분리할 필요가 있다.&lt;/p&gt;
&lt;p&gt;그래서! 기존의 패키지 구조&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;myproject/
    myproject/
        settings.py
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;를&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;myproject/
    myproject/
        settings/
            __init__.py
            base.py
            local.py
            development.py
            production.py
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;로 분리하는 작업을 진행해보자.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;설정 파일 분리&lt;/h2&gt;
&lt;p&gt;일단 모든 환경에 필요한 공통된 설정 정보를 저장할 &lt;code&gt;base.py&lt;/code&gt;에 기존 &lt;code&gt;settings.py&lt;/code&gt;의 정보를 모두 복사하고, 다음 &lt;code&gt;local.py&lt;/code&gt;, &lt;code&gt;development.py&lt;/code&gt;, &lt;code&gt;production.py&lt;/code&gt;에 다음과 같이 &lt;code&gt;base.py&lt;/code&gt;를 import 한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;myproject.settings.base&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이제 환경마다 다르게 가져갈 설정 정보들을 분리해보자.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# local.py&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;myproject.settings.base&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;

&lt;span class="c1"&gt;# local 환경이니까 디버그 모드를 켜야지!&lt;/span&gt;
&lt;span class="n"&gt;DEBUG&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;true&lt;/span&gt;

&lt;span class="c1"&gt;# local 데이터베이스의 정보를 입력한다.&lt;/span&gt;
&lt;span class="n"&gt;DATABASES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;default&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="s1"&gt;&amp;#39;ENGINE&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;django.db.backends.postgresql_psycopg2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s1"&gt;&amp;#39;NAME&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;LOCAL_DB_NAME&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s1"&gt;&amp;#39;USER&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;LOCAL_DB_USER&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s1"&gt;&amp;#39;PASSWORD&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;LOCAL_DB_PASSWORD&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s1"&gt;&amp;#39;HOST&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;LOCAL_DB_HOST&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s1"&gt;&amp;#39;PORT&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;LOCAL_DB_PORT&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위와 같이 분리할 정보를 &lt;code&gt;base.py&lt;/code&gt;에서 지우고 환경에 맞는 파일에 넣어주면 된다.&lt;/p&gt;
&lt;p&gt;이제 애플리케이션이 구동될 때, 변경된 설정 파일을 읽도록 설정해주어야 한다. 프로젝트의 &lt;code&gt;wsgi.py&lt;/code&gt; 파일을 열면 기본 설정 파일을 지정하는 코드가 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;environ&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setdefault&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;DJANGO_SETTINGS_MODULE&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;myproject.settings&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;본인 기본 설정을 &lt;code&gt;local&lt;/code&gt;로 지정할 것이다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;environ&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setdefault&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;DJANGO_SETTINGS_MODULE&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;myproject.settings.local&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="sb"&gt;``&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt; &lt;span class="n"&gt;python&lt;/span&gt;

&lt;span class="err"&gt;그러나&lt;/span&gt; &lt;span class="err"&gt;이런&lt;/span&gt; &lt;span class="err"&gt;하드코딩&lt;/span&gt; &lt;span class="err"&gt;방법&lt;/span&gt; &lt;span class="err"&gt;말고&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;애플리케이션을&lt;/span&gt; &lt;span class="err"&gt;구동할&lt;/span&gt; &lt;span class="err"&gt;때&lt;/span&gt; &lt;span class="err"&gt;다른&lt;/span&gt; &lt;span class="err"&gt;설정을&lt;/span&gt; &lt;span class="err"&gt;주입할&lt;/span&gt; &lt;span class="err"&gt;수&lt;/span&gt; &lt;span class="err"&gt;있어야&lt;/span&gt; &lt;span class="err"&gt;할&lt;/span&gt; &lt;span class="err"&gt;것이다&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="err"&gt;두&lt;/span&gt; &lt;span class="err"&gt;가지&lt;/span&gt; &lt;span class="err"&gt;방법이&lt;/span&gt; &lt;span class="err"&gt;있다&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;

&lt;span class="err"&gt;첫&lt;/span&gt; &lt;span class="err"&gt;번째는&lt;/span&gt; &lt;span class="err"&gt;위에서&lt;/span&gt; &lt;span class="err"&gt;봤던&lt;/span&gt; &lt;span class="sb"&gt;`DJANGO_SETTINGS_MODULE`&lt;/span&gt;&lt;span class="err"&gt;을&lt;/span&gt; &lt;span class="sb"&gt;`.bashrc`&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sb"&gt;`.bash_profile`&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sb"&gt;`.zshrc`&lt;/span&gt;&lt;span class="err"&gt;에&lt;/span&gt; &lt;span class="err"&gt;환경&lt;/span&gt; &lt;span class="err"&gt;변수로&lt;/span&gt; &lt;span class="err"&gt;등록하는&lt;/span&gt; &lt;span class="err"&gt;방법이다&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;

&lt;span class="sb"&gt;``&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt; &lt;span class="n"&gt;bash&lt;/span&gt;
&lt;span class="n"&gt;export&lt;/span&gt; &lt;span class="n"&gt;DJANGO_SETTINGS_MODULE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;myproject&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;settings&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;두 번째는 서버를 띄울 때 설정을 주입하는 방법이다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python manage.py runserver --settings&lt;span class="o"&gt;=&lt;/span&gt;myproject.settings.local
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;참고한 페이지&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://morion4000.com/django-settings-for-multiple-environments/"&gt;Django settings for multiple enviroments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/1626326/how-to-manage-local-vs-production-settings-in-django"&gt;How to manage local vs production settings in Django?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="django"></category></entry><entry><title>Sumblime Text를 OSX Command Line에서 실행</title><link href="/Sumblime-Text%EB%A5%BC-OSX-Command-Line%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89.html" rel="alternate"></link><published>2015-04-15T00:00:00+00:00</published><author><name></name></author><id>tag:,2015-04-15:Sumblime-Text를-OSX-Command-Line에서-실행.html</id><summary type="html">&lt;h3&gt;Sublime Text 설치 확인&lt;/h3&gt;
&lt;p&gt;아래의 커맨드를 통해 서브라임 텍스트가 잘 설치되었나 확인해야 한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/Applications/Sublime\ Text\ 2.app/Contents/SharedSupport/bin/subl .
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;해당 디렉토리를 기준으로 서브라임 텍스트가 열린다면 성공!&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3&gt;Symbolic Link 생성&lt;/h3&gt;
&lt;p&gt;아래 커맨드를 통해 Symbolic link를 생성한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ln -s /Applications/Sublime\ Text\ 2.app/Contents/SharedSupport/bin/subl /usr/local/bin/subl
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;실행하면 &lt;code&gt;/usr/local/bin/&lt;/code&gt; 에 심볼릭 링크가 만들어진다. 본인은 그냥 유저 홈에 bin 디렉토리를 생성해서 거기에 심볼릭 링크를 만들었음.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3&gt;환경 변수 설정&lt;/h3&gt;
&lt;p&gt;환경 변수를 설정한다. &lt;code&gt;echo $PATH&lt;/code&gt; 를 실행해서 본인이 심볼릭 링크를 생성한 디렉토리가 등록되어 있는지 확인한다. 없으면 &lt;code&gt;.bash_profile&lt;/code&gt;이나 &lt;code&gt;.zshrc&lt;/code&gt;를 열어서 다음과 같이 추가해준다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;export PATH=본인의 심볼릭 링크가 있는 디렉토리 경로:&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;PATH&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;export EDITOR=‘subl -w’&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;본인은 &lt;code&gt;PATH&lt;/code&gt; 에 &lt;code&gt;~/bin&lt;/code&gt; 을 추가했다. 아마 &lt;code&gt;/usr/local/bin&lt;/code&gt; 은 이미 등록되어 있을 것 같다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3&gt;마무리&lt;/h3&gt;
&lt;p&gt;터미널을 재실행하거나 &lt;code&gt;source .zshrc&lt;/code&gt;(혹은 &lt;code&gt;.bash_profile&lt;/code&gt;)을 실행하고 &lt;code&gt;subl&lt;/code&gt;을 입력해서 서브라임 텍스트가 열리면 성공!&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h5&gt;참고한 페이지&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/16199581/opening-sublime-text-on-command-line-as-subl-on-mac-os"&gt;http://stackoverflow.com/questions/16199581/opening-sublime-text-on-command-line-as-subl-on-mac-os&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.sublimetext.com/docs/2/osx_command_line.html"&gt;https://www.sublimetext.com/docs/2/osx_command_line.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://egloos.zum.com/sunnmoon/v/1858692"&gt;심볼릭 링크와 하드 링크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Sublime Text 3를 쓰는 사람은 &lt;code&gt;/Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl .&lt;/code&gt;를 실행한다.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="env"></category><category term="sublimetext"></category></entry></feed>