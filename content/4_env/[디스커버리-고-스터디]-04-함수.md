Title: [디스커버리 GO 스터디] 04 함수
Slug: [디스커버리-GO-스터디]-04-함수
Date: 2016-05-22
Tags: go, 디스커버리고, 한빛미디어,

이 포스트는 `한빛미디어`가 출판한 [디스커버리 GO](http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=78786120)의 챕터 04 `함수`를 요약한 내용입니다.

<br>
GO의 서브루틴은 스택으로 구현되며 따라서 재귀호출이 가능하다. 또, `call by value`만 지원하며 주소값을 넘겨 받아서 `call by reference`와 비슷한 효과를 낼 수 있다.

## 값 넘겨주고 넘겨받기

### 값 넘겨주기

다음 두 경우를 비교해 보자.

``` go
func ReadFrom(r io.Reader, lines []string) error {
    ...
}
```
``` go
func ReadFrom(r io.Reader, lines *[]string) error {
    ...
}
```

슬라이스 `lines`는 전자에서 값으로 넘어오고, 후자에서는 포인터로 넘어온다. 뭐가 다른걸까? 슬라이스를 값으로 넘길 경우 실제로는 (배열 포인터, 길이, 용량)이 세가지가 넘어간다. 다음 그림을 참조해보라.

![go-function-slice-as-value]({filename}/images/go-func-slice-value.jpg)

따라서 `ReadFrom` 함수 안에서 `lines` 내부의 요소들을 수정하면 원본 데이터도 같이 수정된다. 배열 자체는 포인터로 관리되고 있기 때문이다. 그렇다면 후자에서는 왜 `lines`를 포인터로 넘길까? 역시 다음 그림을 참조하자.

![go-function-slice-as-reference]({filename}/images/go-func-slice-reference.jpg)

바로 슬라이스의 (배열 포인터, 길이, 용량) 자체를 변경하고 싶기 때문이다.

### 둘 이상의 반환값

GO는 둘 이상의 반환값을 둘 수 있다. `ReadFrom` 함수를 다음과 같이 수정해보자.

``` go
func ReadFrom(r io.Reader, lines *[]string) (int64, error) {
    ...
}
```

`return` 구문은 `return n, err` 같이 간단하게 쉼표로 구분하면 된다. 반환값을 받을 때도 `n, err := ReadFrom(r, lines)` 같이 쉼표로 구분해서 받을 수 있다.

에러를 따로 받는 것이 가능하기 때문에 다음과 같이 단순하게 에러를 처리하는 코드를 작성할 수 있다.

``` go
if err := MyFunc(); err != nil {
    ...
}
```

### 명명된 결과 인자

GO에는 받는 값 뿐만 아니라 반환값에도 이름을 지정할 수 있다. 하지만 특별한 경우가 아니고는 별로 쓸모는 없다.

``` go
func WriteTo(w io.Writer, lines []string) (n int64, err error) {
    ...
}
```

### 가변 인자

특정 인자의 개수를 예측하기 어려운 경우, 슬라이스를 인자로 설정하고 받아도 무관하지만 가변 인자를 받을 수도 있다. 이 경우, 받은 가변 인자는 자동으로 슬라이스로 취급된다. 원본이 슬라이스인 변수를 가변 인자 자리에 넣을 수도 있는데 이 경우는 호출 시 `...`를 붙이면 된다.

``` go
func WriteTo(w io.Writer, lines... string) (n int64, err error) {
    ...
}

WriteTo(w, "hi", "world", "go lang")

lines := []string("hi", "world", "go lang")
WriteTo(w, lines...)
```

<br>
## 값으로 취급되는 함수

GO에서는 함수는 일급 객체로 취급된다. 따라서 함수를 변수로서 넘길 수 있고, 반환할 수도 있다.

### 함수 리터럴

지금까지는 항상 함수에 이름을 지정했지만, 순수하게 함수의 값만을 표현할 수도 있고 이것을 함수 리터럴이라고 부른다.

``` go
func(a, b int) int {
    return a + b
}
```

### 고계 함수

함수를 받거나 반환하는 함수를 고계 함수라 한다.

``` go
func ReadFrom(r io.Reader, f func(line string)) error {
    ...
}
```

### 클로저

외부에서 선언한 변수에 함수 리터럴이 마음대로 접근 가능한 코드를 의미한다. 예제를 보면 이해가 쉬울 것이다.

``` go
func ExampleReadFrom_append() {
    r := strings.NewReader("bill\ntom\njane\n")
    var lines []string
    err := ReadFrom(r, func(line string) {
        lines = append(lines, line)
    })
    
    if err != nil {
        fmt.Println(err)
    }
    fmt.Println(lines)
    // output: [bill tom jane]
}
```

예제에서 `lines` 슬라이스는 함수 리터럴 안에서 사용되고, `ReadFrom` 함수가 반환되고 나서도 함수 리터럴 내에서 업데이트 된 `lines`의 내용은 여전히 유지된다.

### 제네레이터(생성기)

클로저를 이용하면 제네레이터를 만들 수 있다. 제네러이터를 이용하면 지연 평가(lazy evaluation)이나 무한 크기의 자료구조를 만들 수 있다. 다음 예제는 호출시마다 증가된 값을 받는 제네레이터다.

``` go
func NewIntGenerator() func() int {
    var next int
    return func() int {
        next++
        return next
    }
}

func ExampleNewIntGenerator() {
    gen := NewIntGenerator()
    fmt.Println(gen(), gen(), gen(), gen(), gen())
    fmt.Println(gen(), gen(), gen(), gen(), gen())
    // output:
    // 1 2 3 4 5
    // 6 7 8 9 10
}
```

`NewIntGenerator`는 함수를 반환하는 고계 함수이다. 동시에 이 함수가 반환하는 함수는 클로저이다. 반환하는 함수 리터럴이 외부에 있는 `next` 변수에 접근하고 있기 때문이다.

### 명명된 자료형

다음과 같이 자료형에 새 이름을 붙일 수 있다.

``` go
type rune int32
type runes []rune
```

자료형이 같아도(ex: 같은 `int`이어도) 다른 커스텀 타입을 지정했을 경우, 컴파일 에러를 낼 수 있으므로 실수를 방지할 수 있다. 또 특정 자료형을 추상화 할 수 있으므로, 타입에 변경이 있을 경우 코드 변경 사항을 최소화 할 수 있다.

### 명명된 함수형

명명된 자료형을 이용하면 함수형의 타입을 지정하는 것도 가능하다.

``` go
type BinOp func(int, int) int
```

### 인자 고정

함수의 인자를 고정할 수 있다. (그냥 함수를 추상화해서 특정 파라메터를 외부로 노출시키지 않겠다는 말인듯;;)

``` go
type MultiSet map[string]int
func Insert(m MultiSet, val string)

m := NewMultiSet()
ReadFrom(r, func(line string) {
    Insert(m, line)
})
```

그러나 다음과 같이 함수를 추상화하면 `m MultiSet` 인자를 고정시킬 수 있다.

``` go
func InsertFunc(m MultiSet) func(val string) {
    return func(val string) {
        Insert(m, val)
    }
}

m := NewMultiSet()
ReadFrom(r, InsertFunc(m))
```

좀 더 일반화 시킬 수도 있다.

``` go
type SetOp func(m MultiSet, val string)
func BindMap(f SetOp, m MultiSet) func(val string) {
    return func(val string) {
        f(m, val)
    }
}

m := NewMultiSet()
ReadFrom(r, BindMap(Insert, m))
```
