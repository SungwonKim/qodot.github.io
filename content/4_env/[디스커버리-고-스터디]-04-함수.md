Title: [디스커버리 GO 스터디] 04 함수
Slug: [디스커버리-GO-스터디]-04-함수
Date: 2016-05-22
Tags: go, 디스커버리고, 한빛미디어,

이 포스트는 `한빛미디어`가 출판한 [디스커버리 GO](http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=78786120)의 챕터 04 `함수`를 요약한 내용입니다.

<br>
GO의 서브루틴은 스택으로 구현되며 따라서 재귀호출이 가능하다. 또, `call by value`만 지원하며 주소값을 넘겨 받아서 `call by reference`와 비슷한 효과를 낼 수 있다.

## 값 넘겨주고 넘겨받기

### 값 넘겨주기

다음 두 경우를 비교해 보자.

``` go
func ReadFrom(r io.Reader, lines []string) error {
    ...
}
```
``` go
func ReadFrom(r io.Reader, lines *[]string) error {
    ...
}
```

슬라이스 `lines`는 전자에서 값으로 넘어오고, 후자에서는 포인터로 넘어온다. 뭐가 다른걸까? 슬라이스를 값으로 넘길 경우 실제로는 (배열 포인터, 길이, 용량)이 세가지가 넘어간다. 다음 그림을 참조해보라.

![go-function-slice-as-value]({filename}/images/go-func-slice-value.jpg)

따라서 `ReadFrom` 함수 안에서 `lines` 내부의 요소들을 수정하면 원본 데이터도 같이 수정된다. 배열 자체는 포인터로 관리되고 있기 때문이다. 그렇다면 후자에서는 왜 `lines`를 포인터로 넘길까? 역시 다음 그림을 참조하자.

![go-function-slice-as-reference]({filename}/images/go-func-slice-reference.jpg)

바로 슬라이스의 (배열 포인터, 길이, 용량) 자체를 변경하고 싶기 때문이다.

### 둘 이상의 반환값

GO는 둘 이상의 반환값을 둘 수 있다. `ReadFrom` 함수를 다음과 같이 수정해보자.

``` go
func ReadFrom(r io.Reader, lines *[]string) (int64, error) {
    ...
}
```

`return` 구문은 `return n, err` 같이 간단하게 쉼표로 구분하면 된다. 반환값을 받을 때도 `n, err := ReadFrom(r, lines)` 같이 쉼표로 구분해서 받을 수 있다.

에러를 따로 받는 것이 가능하기 때문에 다음과 같이 단순하게 에러를 처리하는 코드를 작성할 수 있다.

``` go
if err := MyFunc(); err != nil {
    ...
}
```

### 명명된 결과 인자

GO에는 받는 값 뿐만 아니라 반환값에도 이름을 지정할 수 있다. 하지만 특별한 경우가 아니고는 별로 쓸모는 없다.

``` go
func WriteTo(w io.Writer, lines []string) (n int64, err error) {
    ...
}
```

### 가변 인자

특정 인자의 개수를 예측하기 어려운 경우, 슬라이스를 인자로 설정하고 받아도 무관하지만 가변 인자를 받을 수도 있다. 이 경우, 받은 가변 인자는 자동으로 슬라이스로 취급된다. 원본이 슬라이스인 변수를 가변 인자 자리에 넣을 수도 있는데 이 경우는 호출 시 `...`를 붙이면 된다.

``` go
func WriteTo(w io.Writer, lines... string) (n int64, err error) {
    ...
}

WriteTo(w, "hi", "world", "go lang")

lines := []string("hi", "world", "go lang")
WriteTo(w, lines...)
```

<br>
## 값으로 취급되는 함수

GO에서는 함수는 일급 객체로 취급된다. 따라서 함수를 변수로서 넘길 수 있고, 반환할 수도 있다.

### 함수 리터럴

지금까지는 항상 함수에 이름을 지정했지만, 순수하게 함수의 값만을 표현할 수도 있고 이것을 함수 리터럴이라고 부른다.

``` go
func(a, b int) int {
    return a + b
}
```

### 고계 함수

함수를 받거나 반환하는 함수를 고계 함수라 한다.

``` go
func ReadFrom(r io.Reader, f func(line string)) error {
    ...
}
```

### 클로저

외부에서 선언한 변수에 함수 리터럴이 마음대로 접근 가능한 코드를 의미한다. 예제를 보면 이해가 쉬울 것이다.

``` go
func ExampleReadFrom_append() {
    r := strings.NewReader("bill\ntom\njane\n")
    var lines []string
    err := ReadFrom(r, func(line string) {
        lines = append(lines, line)
    })
    
    if err != nil {
        fmt.Println(err)
    }
    fmt.Println(lines)
    // output: [bill tom jane]
}
```

예제에서 `lines` 슬라이스는 함수 리터럴 안에서 사용되고, `ReadFrom` 함수가 반환되고 나서도 함수 리터럴 내에서 업데이트 된 `lines`의 내용은 여전히 유지된다.

### 제네레이터(생성기)

클로저를 이용하면 제네레이터를 만들 수 있다. 제네러이터를 이용하면 지연 평가(lazy evaluation)이나 무한 크기의 자료구조를 만들 수 있다. 다음 예제는 호출시마다 증가된 값을 받는 제네레이터다.

``` go
func NewIntGenerator() func() int {
    var next int
    return func() int {
        next++
        return next
    }
}

func ExampleNewIntGenerator() {
    gen := NewIntGenerator()
    fmt.Println(gen(), gen(), gen(), gen(), gen())
    fmt.Println(gen(), gen(), gen(), gen(), gen())
    // output:
    // 1 2 3 4 5
    // 6 7 8 9 10
}
```

`NewIntGenerator`는 함수를 반환하는 고계 함수이다. 동시에 이 함수가 반환하는 함수는 클로저이다. 반환하는 함수 리터럴이 외부에 있는 `next` 변수에 접근하고 있기 때문이다.

### 명명된 자료형

다음과 같이 자료형에 새 이름을 붙일 수 있다.

``` go
type rune int32
type runes []rune
```

자료형이 같아도(ex: 같은 `int`이어도) 다른 커스텀 타입을 지정했을 경우, 컴파일 에러를 낼 수 있으므로 실수를 방지할 수 있다. 또 특정 자료형을 추상화 할 수 있으므로, 타입에 변경이 있을 경우 코드 변경 사항을 최소화 할 수 있다.

### 명명된 함수형

명명된 자료형을 이용하면 함수형의 타입을 지정하는 것도 가능하다.

``` go
type BinOp func(int, int) int
```

### 인자 고정

함수의 인자를 고정할 수 있다. (그냥 함수를 추상화해서 특정 파라메터를 외부로 노출시키지 않겠다는 말인듯;;)

``` go
type MultiSet map[string]int
func Insert(m MultiSet, val string)

m := NewMultiSet()
ReadFrom(r, func(line string) {
    Insert(m, line)
})
```

그러나 다음과 같이 함수를 추상화하면 `m MultiSet` 인자를 고정시킬 수 있다.

``` go
func InsertFunc(m MultiSet) func(val string) {
    return func(val string) {
        Insert(m, val)
    }
}

m := NewMultiSet()
ReadFrom(r, InsertFunc(m))
```

좀 더 일반화 시킬 수도 있다.

``` go
type SetOp func(m MultiSet, val string)
func BindMap(f SetOp, m MultiSet) func(val string) {
    return func(val string) {
        f(m, val)
    }
}

m := NewMultiSet()
ReadFrom(r, BindMap(Insert, m))
```

### 패턴의 추상화

전에 만들었던 이 제네레이터를 보자.

```go
func NewIntGenerator() func() int {
	var next int
    return func() int {
    	next++
        return next
    }
}
```

만약 계속해서 `NewVertexIDGenerator`, `NewEdgeIDGenerator`따위의 것들을 만들어야 한다면, 위의 `NewIntGenerator`와 동일한 코드를 계속해서 복사&붙여넣기 할 게 아니라, 추상화를 고려해보자.

```go
func NewVertexIDGenerator func() VertexID {
	var next int
    return func() VertexID {
    	next++
        return VertexID(next)
    }
}
```

가 아니라,

```go
func NewVertexIDGenerator func () VertexID {
	gen := NewIntGenerator()
    return func() VertexID {
    	return VertexID(gen())
    }
}
```

처럼 하면 중복을 피할 수 있을 것이다.

### 자료구조에 담은 함수

go에서는 함수가 일급 객체이기 때문에 자료구조에도 함수를 담을 수 있다. 여러가지 연산을 지원하는 `Eval`이라는 함수를 만들어 보자.

```go
type BinOp func(int, int) int

func Eval(opMap map[string]BinOp, expr string) int {
	// 3장에서 스택 계산기를 만든 모양임
	var ops []string // 연산자
    var nums []int // 피연산자
    
    pop := func() int {
    	last := nums[len(nums)-1]
        nums = nums[:len(nums)-1]
        return last
    }
    
    reduce := func(higher string) {
    	for len(ops) > 0 {
        	op := ops[len(ops)-1]
            if strings.Index(higher, op) < 0 {
            	// 목록에 없는 연산자이므로 종료
            	return
            }
            ops = ops[:len(ops)-1]
            if op == "(" {
            	// 괄호를 제거하였으므로 종료
                return
            }
            b, a := pop(), pop()
            if f := opMap[op]; f != nil {
            	nums = append(nums, f(a, b))
            }
        }
    }
}
```

그리고 사용 가능한 연산자를 정의해서 파라메터(opMap)로 넘겨준다. 이 때, 함수를 `map` 자료구조에 담아 넘겨준다.

```go
opMap := map[string]BinOp {
	"+": func(a, b int) int { return a + b },
    "-": func(a, b int) int { return a - b },
    "*": func(a, b int) int { return a * b },
    "/": func(a, b int) int { return a / b },
}
```

<br>
## 메서드

보통 객체지향 프로그래밍을 지원하는 언어라면 커스텀 클래스 안에서 메서드를 사용할 수 있게 지원할 것이다. 그런데 go에서는 명명된 모든 자료형에 대해서 메서드를 정의할 수 있다. 기본적으로 임의의 타입 `Type`에 대한 메서드 정의는 다음과 같다.

```go
func (Type T) MethodName(p1 T1, p2 T2) R1
```

### 단순 자료형 메서드

다음 `VertexID` 타입을 보자.

```go
type VertexID int

func ExampleVertexID_print() {
	i := VertexID(100)
    fmt.Println(i) // 100
}
```

`VertexID`라는 타입으로 정의되어 있긴 하지만 출력할 때는 일반 정수형과 같다. 그렇다면 `VertexID` 타입에 대해서만 다른 형태의 출력을 원한다면 어떻게 해야할까?

```go
func (id VertexID) String() string {
	return fmt.Sprintf("VertexID(%d)", id)
}
```

다시 같은 코드로 출력해보자.

```go
func ExampleVertexID_print() {
	i := VertexID(100)
    fmt.Println(i) // VertexID(100)
}
```

### 문자열 다중 집합

중요하지 않은 내용이라 생략

### 포인터 리시버

메서드를 추가할 때 타입의 포인터에 추가할 수도 있다.

```go
func WriteTo(w io.Writer, adjList [][]int) error
func ReadFrom(w io.Reader, adjList *[][]int) error
```

### public, private

go에서는 간단하게 메서드의 공개 여부를 지정할 수 있는데, 메서드 이름을 대문자로 시작하게 하면 public, 소문자로 시작하게 하면 private이다. 사실 메서드 뿐 아니라 모든 정의된 자료형, 변수, 상수, 함수에 적용된다. private으로 설정된 요소들은 같은 모듈 안에서만 사용할 수 있다.
