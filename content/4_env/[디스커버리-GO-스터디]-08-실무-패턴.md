Title: [디스커버리 GO 스터디] 08 실무 패턴
Slug: [디스커버리-GO-스터디]-08-실무-패턴
Date: 2016-07-10
Tags: go, 디스커버리고, 한빛미디어,

이 포스트는 `한빛미디어`가 출판한 [디스커버리 GO](http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=78786120)의 챕터 10 `실무 패턴`을 요약한 내용입니다.

## 오버로딩

go는 오버로딩을 지원하지 않는다. 그렇다고 해서 go에서 오버로딩을 어떻게 흉내내는지를 알려고 하기 보다는, 왜 오버로딩이 필요한지 한 번 더 생각해보자.

- 자료형에 따라 다른 이름 붙이기: 이 경우는 오버로딩이 별로 필요 없다. 오버로딩을 따로 하지 말고 이 경우에는 자료형에 따라서 다른 함수의 이름을 붙이자. (뭐야 이딴게 해결책? ㅡㅡ)
- 자료형 스위치 활용하기: 오버로딩이 반드시 필요한 경우라면, 인터페이스로 인자를 받고 자료형 스위치를 사용해서 자료형에 맞게 다른 코드가 수행될 수 있게 할 수 있다.
- 동일한 자료형의 자료 개수에 따른 오버로딩:  `max(a, b)`와 `max(a, b, c)` 같은 경우인데, 이 경우는 가변인자를 사용하면 된다.
- 다양한 인자 넘기기: 인자 자체를 구조체로 묶어 넘기는 것을 고려해본다.

### 연산자 오버로딩

go는 연산자 오버로딩도 지원하지 않는다. (되는게 뭐냐 ㅡㅡ) 따라서 연산자 오버로딩이 왜 필요한지 먼저 생각해보자. 보통은 편의성 때문일 경우가 많은데, 이 경우 인터페이스를 이용하여 쉽게 해결할 수 있다. 예를들어 `sort.Interface`의 `Less`는 부등호 연산자 `<`를 오버로딩하기 위한 것이다. 즉, 오버로딩 없이 `Less`를 호출하면 된다.

<br>
## 템플릿 및 제네릭 프로그래밍

제네릭은 자료형을 배제하여 프로그래밍 할 수 있는 패러다임이다. go는 제네릭을 지원하지 않는다(...).

### 유닛 테스트

`JUnit` 같은 테스트의 `assetEqual`과 같은 함수를 어떻게 대체할 수 있을까?

```go
if expected != actual {
    t.Error("Not Equal!")
}
```

`assetEqual` 한 줄로 간결하게 표현할 수 있는 것이 3줄로 늘어났다. 그래서 `assetEqual`을 직접 작성해보자.


```go
func assertEqual(t *testing T, expected, actual interface{}) {
    if !reflect.DeepEqual(expected, actual) {
        t.Errorf("%v != %v", expected, actual)
    }
}
```

`reflect` 패키지는 자료형과 값에 대한 정보를 얻을 수 있는 패키지이다.

### 컨테이너 알고리즘

...? 그냥 인터페이스 쓰라는 이야기

### 자료형 메타 데이터

`reflect.TypeOf` 함수를 쓰면 타입을 문자열로 얻을 수 있다. js의 `typeof` 같은거...

### go generate

C의 매크로 같은 기능이다.

<br>
## 객체 지향

go는 객체지향을 완전히 지원하지 않는다. 후...

### 다형성

인터페이스를 이용해서 구현 가능하다.

```go
type Shape interface {
    Area() float32
}

type Square struct {
    Size float32
}

func (s Square) Area() float32 {
    return s.Size * s.Size
}

type Rectangle struct {
    Width, Height float32
}

func (r Rectangle) Area() float32 {
    return r.Width * r.Height
}

type Triangle struct {
    Width, Height float32
}

func (t Triangle) Area() float32 {
    return 0.5 * t.Width * t.Height
}

func TotalArea(shapes []Shape) float32 {
    var total float32
    for _, shape := range shapes {
        total += shape.Area()
    }
    return total
}

func ExampleTotalArea() {
    fmt.Println(TotalArea([]Shape {
        Square{3}, Rectangle{4, 5}, Triangle{6, 7},
    }))
}
```

###  인터페이스

go에서는 java처럼 인터페이스를 `implements` 구문을 사용해 작성해주지 않아도 인터페이스의 메서드를 구현하기만 하면, 그 인터페이스를 `implements` 한 것이 된다. (duck typing?)

### 상속

#### 메서드 추가

```go
type Rectangle struct {
    Width, Height float32
}

func (r Rectangle) Area() float32 {
    return r.Width * r.Height
}
```

일 때, 구조체 안에 다른 구조체를 밀어넣어서 확장할 수 있다.

```go
type RectangleCircum struct{ Rectangle }

func (r RectangleCircum) Circum() float32 {
    return 2 * (r.Width + r.Height)
}
```

생성자는 다음과 같이 만들 수 있다.

```go
func NewRectangleCircum(width, height float32) *RectangleCircum {
    return &RectangleCircum{Rectangle{width, height}}
}
```

#### 오버라이딩

역시 구조체 내장으로 해결이 가능하다.

```go
type WrongRectangle struct{ Rectangle }

func (r WrongRectangle) Area() float32 {
    return r.Rectangle.Area() * 2
}
```

### 서브 타입

바로 위의 `WrongRectangle` 예제를 보자. `Area` 메소드로 구현이 되므로 `Shape` 인터페이스로 취급이 된다. `RectangleCircum`의 경우에는 직접 `Area` 메소드를 구현하고 있지 않지만, `Rectangle` 구조체를 내장하고 있고, `Area`를 호출시 내부의 `Area`가 호출될 것이므로, 역시 `Shape` 인터페이스를 구현한 것이 된다.

어떤 자료형이 특정 인터페이스를 구현하고 있는지 알아보려면 `reflect.Type.Implements` 메소드를 이용하면 된다.

### 캡슐화

public(이름이 대문자로 시작)과 private(이름이 소문자로 시작)은 있지만 protected는 없다. 그럼 패키지 내에서 호출을 막으려면 어떻게 해야할까? 사실 필자는 패키지 내에서 참조를 막아서 얻는 이득이 뭔지 모르겠다. (???)

내가 만든 다른 패키지에서는 접근이 가능하게 하고 싶은데, 남이 만든 패키지에서 접근하지 못하게 하려면 내부 패키지를 이용하면 되는데, 패키지 경로에 `internal`을 넣으면 경로에 있는 패키지를 포함 범위에서만 참조가 가능하다.

<br>
## 디자인 패턴

그냥 디자인 패턴 책을 사서 보자. **PASS**
