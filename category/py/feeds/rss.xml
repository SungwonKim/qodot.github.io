<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>waiting for qodot - py</title><link>https://qodot.github.io/</link><description></description><lastBuildDate>Thu, 12 Jan 2017 00:00:00 +0900</lastBuildDate><item><title>Flask에서 Pytest 환경 설정하기</title><link>https://qodot.github.io/Flask%EC%97%90%EC%84%9C-Pytest-%ED%99%98%EA%B2%BD-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0.html</link><description>&lt;p&gt;Flask, SQLAlchemy, Alembic을 이용하는 프로젝트에서 &lt;a href="http://doc.pytest.org/en/latest/"&gt;Pytest&lt;/a&gt;를 이용해 테스트 환경을 구축할 수 있다. &lt;code&gt;pip&lt;/code&gt;을 이용해서 간단하게 설치가 가능하다.&lt;/p&gt;
&lt;p&gt;원활한 테스트를 위해서, 아마도 다음과 같은 개념들이 필요할 것이다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Flask Application Context&lt;/li&gt;
&lt;li&gt;Flask Test Client&lt;/li&gt;
&lt;li&gt;테스트 전용 데이터베이스&lt;/li&gt;
&lt;li&gt;테스트 케이스마다 필요한 데이터를 Insert 하고, 테스트가 완료되면 트랜잭션을 롤백하는 세션&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Pytest로 이 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">qodot</dc:creator><pubDate>Thu, 12 Jan 2017 00:00:00 +0900</pubDate><guid isPermaLink="false">tag:qodot.github.io,2017-01-12:/Flask에서-Pytest-환경-설정하기.html</guid><category>python</category><category>pyrest</category><category>flask</category><category>sqlalchemy</category><category>alembic</category></item><item><title>SQLAlchemy Transaction 관리 Practice 공유</title><link>https://qodot.github.io/SQLAlchemy-Transaction-%EA%B4%80%EB%A6%AC-Practice-%EA%B3%B5%EC%9C%A0.html</link><description>&lt;h2&gt;개요&lt;/h2&gt;
&lt;p&gt;기본적으로 SQLAlchemy에서는 (&lt;code&gt;autocommit=True&lt;/code&gt; 옵션을 주지 않는 이상) 수동으로 트랜잭션을 관리해야 한다. 예를 들면 이런 거다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;session&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Session&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;new_user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;User&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_user&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;commit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이렇게 항상, &lt;code&gt;session.commit()&lt;/code&gt; 혹은 &lt;code&gt;session.rollback()&lt;/code&gt;을 붙여주어야 트랜잭션이 끝나면서 변경 내용이 반영된다. 이렇게 간단한 수준의 코드라면 별 문제 없겠지만, 만약 큰 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">qodot</dc:creator><pubDate>Sat, 27 Aug 2016 00:00:00 +0900</pubDate><guid isPermaLink="false">tag:qodot.github.io,2016-08-27:/SQLAlchemy-Transaction-관리-Practice-공유.html</guid><category>python</category><category>sqlalchemy</category></item><item><title>SQLAlchemy-PostgreSQL에서의 JSON 타입 업데이트</title><link>https://qodot.github.io/SQLAlchemy-PostgreSQL%EC%97%90%EC%84%9C%EC%9D%98-JSON-%ED%83%80%EC%9E%85-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8.html</link><description>&lt;p&gt;PostgreSQL 9.3 과 SQLAlchemy를 이용해서 JSON 타입의 컬럼을 업데이트 하려고 했는데 되질 않았다. 찾다보니 한 아티클&lt;a href="https://bashelton.com/2014/03/updating-postgresql-json-fields-via-sqlalchemy/"&gt;Updating PostgreSQL JSON fields via SQLAlchemy&lt;/a&gt;을 찾게 되어 내용을 정리해본다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;기본적인 업데이트 방법&lt;/h2&gt;
&lt;p&gt;아마 다들 알다시피, SQLAlchemy에서는 다음과 같은 방법으로 간단하게 update 쿼리를 날릴 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;session&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Session&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;User …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">qodot</dc:creator><pubDate>Fri, 26 Aug 2016 00:00:00 +0900</pubDate><guid isPermaLink="false">tag:qodot.github.io,2016-08-26:/SQLAlchemy-PostgreSQL에서의-JSON-타입-업데이트.html</guid><category>python</category><category>sqlalchemy</category><category>postgresql</category></item><item><title>Django에서 Celery로 Task Queue 구축</title><link>https://qodot.github.io/Django%EC%97%90%EC%84%9C-Celery%EB%A1%9C-Task-Queue-%EA%B5%AC%EC%B6%95.html</link><description>&lt;h2&gt;개요&lt;/h2&gt;
&lt;p&gt;서비스를 만들다보면 유저에게 특정 요청이 들어오면 이메일을 보내야 할 때가 있다. 그런데 이 때, 메일 서버의 상태가 좀 이상하다면? 혹은 서버에 이미 보내야 할 메일이 산더미처럼 쌓여있다면? 이메일 전송이 지연되면 유저의 요청도 지연되고, 유저는 기다리다 지쳐 서비스 이용을 관두게 된다 ㅜㅜ 그럼 어떡하지?&lt;/p&gt;
&lt;p&gt;일단 유저에게는 요청이 완료되었다는 응답을 보내고 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">qodot</dc:creator><pubDate>Tue, 05 Apr 2016 00:00:00 +0900</pubDate><guid isPermaLink="false">tag:qodot.github.io,2016-04-05:/Django에서-Celery로-Task-Queue-구축.html</guid><category>python</category><category>django</category><category>celery</category></item><item><title>Python Asyncio</title><link>https://qodot.github.io/Python-Asyncio.html</link><description>&lt;h2&gt;개요&lt;/h2&gt;
&lt;p&gt;파이썬 3.3에 추가된 &lt;code&gt;asyncio&lt;/code&gt;는, 동시성 문제를 코루틴&lt;code&gt;coroutine&lt;/code&gt; 기반으로 처리하는 비동기 IO 라이브러리다. 동시성 문제를 처리하는 방법은 대표적으로 쓰레드와 콜백 패턴이 있다.&lt;/p&gt;
&lt;h3&gt;Thread&lt;/h3&gt;
&lt;p&gt;가장 대표적인 방법이다. 대중적인 방법이므로 이해도 쉽고 적용도 쉽다. 그런데 쓰레드에는 다음과 같은 문제가 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;쓰레드를 생성하는데 드는 오버헤드&lt;/li&gt;
&lt;li&gt;쓰레드를 만들 때마다 추가되는 메모리 …&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">qodot</dc:creator><pubDate>Sun, 27 Mar 2016 00:00:00 +0900</pubDate><guid isPermaLink="false">tag:qodot.github.io,2016-03-27:/Python-Asyncio.html</guid><category>python</category></item><item><title>Python Generator</title><link>https://qodot.github.io/Python-Generator.html</link><description>&lt;p&gt;파이썬에서 제네레이터는 이터레이터&lt;code&gt;iterator&lt;/code&gt;의 확장 개념이라고 볼 수 있다. 이터레이터는 '순회 가능한&lt;code&gt;iterable&lt;/code&gt;' 객체로서, 실제로는 &lt;code&gt;__next__&lt;/code&gt; 함수가 구현되어 있는 객체라고 보면 된다. 예를 들면, &lt;code&gt;for&lt;/code&gt;문을 수행할 때, 내부적으로 &lt;code&gt;__next__&lt;/code&gt; 함수를 호출해서 동작한다. 제네레이터는 이터레이터의 확장 개념으로, &lt;code&gt;__next__&lt;/code&gt; 함수의 리턴값은 &lt;code&gt;yield&lt;/code&gt; 구문값으로 대신한다. 즉, &lt;code&gt;yield&lt;/code&gt; 구문이 포함된 함수를 제네레이터라고 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">qodot</dc:creator><pubDate>Sun, 06 Mar 2016 00:00:00 +0900</pubDate><guid isPermaLink="false">tag:qodot.github.io,2016-03-06:/Python-Generator.html</guid><category>python</category></item><item><title>Python으로 텔레그램 봇 만들기</title><link>https://qodot.github.io/Python%EC%9C%BC%EB%A1%9C-%ED%85%94%EB%A0%88%EA%B7%B8%EB%9E%A8-%EB%B4%87-%EB%A7%8C%EB%93%A4%EA%B8%B0.html</link><description>&lt;h2&gt;개요 및 기획&lt;/h2&gt;
&lt;p&gt;회사에 있는 하루 중 가장 힘든 시간은 바로 점심을 뭘 먹을지 결정하는 순간이다. 사실 누구든 아무거나 먹어도 상관 없는데 아무도 결정하지 못하는 상황을 자주 마주치게 된다. 그래서 나는 우리 대신 빠른 결정을 내려줄 무언가가 필요하다고 생각했다.&lt;/p&gt;
&lt;p&gt;식당을 등록/제거하고, 등록된 식당을 조회하고, 등록된 식당 중에 하나를 랜덤으로 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">qodot</dc:creator><pubDate>Sun, 06 Mar 2016 00:00:00 +0900</pubDate><guid isPermaLink="false">tag:qodot.github.io,2016-03-06:/Python으로-텔레그램-봇-만들기.html</guid><category>python</category><category>telegram</category></item><item><title>Pyenv, Virtualenv, Autoenv로 Python 환경 설정하기</title><link>https://qodot.github.io/Pyenv-Virtualenv-Autoenv%EB%A1%9C-Python-%ED%99%98%EA%B2%BD-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0.html</link><description>&lt;h2&gt;개요&lt;/h2&gt;
&lt;p&gt;이전의 파이썬의 가상환경은 &lt;code&gt;virtualenv&lt;/code&gt;를 이용해서 관리했었다. 그러나 그것만으로는 다양한 파이썬 버전을 관리할 수가 없었기 때문에, (Ruby의 &lt;code&gt;rbenv&lt;/code&gt;처럼)이 문제를 해결하기 위한 도구가 필요했고 그게 바로 &lt;code&gt;pyenv&lt;/code&gt;이다. &lt;code&gt;virtualenv&lt;/code&gt;의 기능도 &lt;code&gt;pyenv&lt;/code&gt;의 플러그인(&lt;code&gt;pyenv-virtualenv&lt;/code&gt;)을 이용하면 동일하게 사용할 수 있기 때문에 &lt;code&gt;pyenv&lt;/code&gt;를 안 쓸 이유가 없다 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">qodot</dc:creator><pubDate>Sat, 30 Jan 2016 00:00:00 +0900</pubDate><guid isPermaLink="false">tag:qodot.github.io,2016-01-30:/Pyenv-Virtualenv-Autoenv로-Python-환경-설정하기.html</guid><category>python</category></item><item><title>Alembic Quickstart</title><link>https://qodot.github.io/Alembic-Quickstart.html</link><description>&lt;h2&gt;개요&lt;/h2&gt;
&lt;p&gt;Rails나 Django 같은 모던 웹 프레임워크의 ORM에서는, 반복되는 DB 스키마 변경을 수월하게 진행 할 수 있도록 전용 마이그레이션 툴이 ORM에 내장되어 있다. 그러나 SQLAlchemy에서는 기본적으로 테이블의 생성은 가능하나, 생성된 테이블의 스키마 변경은 지원하지 않는데, 이를 수월하게 만들어 주는 툴이 바로 Alembic이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;설치&lt;/h2&gt;
&lt;p&gt;그냥 &lt;code&gt;pip&lt;/code&gt;으로 설치한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip install alembic …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">qodot</dc:creator><pubDate>Wed, 25 Nov 2015 00:00:00 +0900</pubDate><guid isPermaLink="false">tag:qodot.github.io,2015-11-25:/Alembic-Quickstart.html</guid><category>python</category><category>alembic</category><category>sqlalchemy</category></item><item><title>SQLAlchemy Quickstart</title><link>https://qodot.github.io/SQLAlchemy-Quickstart.html</link><description>&lt;p&gt;SQLAlchemy를 사용하기 위한 기본적인 설정을 하는 방법을 요약해본다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;설치&lt;/h2&gt;
&lt;p&gt;그냥 &lt;code&gt;pip&lt;/code&gt;으로 설치하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;pip&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;sqlalchemy&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;설정&lt;/h2&gt;
&lt;h3&gt;접속 설정&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sqlalchemy&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;create_engine&lt;/span&gt;

&lt;span class="n"&gt;URL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;postgresql://&amp;lt;username&amp;gt;:&amp;lt;password@&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/&amp;lt;dbname&amp;gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;engine&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;create_engine&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;URL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;echo&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;간단하게 &lt;code&gt;engine.execute('SELECT 1').scalar()&lt;/code&gt; 같은 코드를 실행해보면 접속을 테스트해 볼 수 있다 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">qodot</dc:creator><pubDate>Fri, 20 Nov 2015 00:00:00 +0900</pubDate><guid isPermaLink="false">tag:qodot.github.io,2015-11-20:/SQLAlchemy-Quickstart.html</guid><category>python</category><category>sqlalchemy</category></item><item><title>Django 설정을 환경 변수로 관리하기</title><link>https://qodot.github.io/Django-%EC%84%A4%EC%A0%95%EC%9D%84-%ED%99%98%EA%B2%BD-%EB%B3%80%EC%88%98%EB%A1%9C-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0.html</link><description>&lt;h2&gt;개요&lt;/h2&gt;
&lt;p&gt;설정 정보를 다루다 보면 코드에 그대로 적어서는 안되는 정보들이 있다. 예를 들어 Github의 public 계정을 사용할 경우, 불특정 다수가 서비스의 상용 데이터베이스의 접속 정보를 알아서는 안될 것이다.&lt;/p&gt;
&lt;p&gt;그래서, 간단하게 django 설정 정보를 환경 변수로 등록해서 repository에 노출되지 않도록 해보자. (SECRET_KEY를 예로 들겠음) 만약 virtualenv를 쓰고 있지 않다면 상당히 간단하다 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">qodot</dc:creator><pubDate>Thu, 30 Jul 2015 00:00:00 +0900</pubDate><guid isPermaLink="false">tag:qodot.github.io,2015-07-30:/Django-설정을-환경-변수로-관리하기.html</guid><category>python</category><category>django</category></item><item><title>Django settings.py 환경 분리</title><link>https://qodot.github.io/Django-settings.py-%ED%99%98%EA%B2%BD-%EB%B6%84%EB%A6%AC.html</link><description>&lt;h2&gt;개요&lt;/h2&gt;
&lt;p&gt;애플리케이션을 배포하게 되면, 장비에 따라 필요한 라이브러리, 데이터베이스 정보 등 설정 정보를 다르게 가져가야 한다. Django 프로젝트를 생성하면 기본적으로 1개의 &lt;code&gt;settings.py&lt;/code&gt;가 있는데, 설정 정보를 따로 가져가기 위해서는 파일을 분리할 필요가 있다.&lt;/p&gt;
&lt;p&gt;그래서! 기존의 패키지 구조&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;myproject/
    myproject/
        settings.py
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;를&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;myproject/
    myproject/
        settings/
            __init__.py
            base.py …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">qodot</dc:creator><pubDate>Wed, 29 Jul 2015 00:00:00 +0900</pubDate><guid isPermaLink="false">tag:qodot.github.io,2015-07-29:/Django-settings.py-환경-분리.html</guid><category>python</category><category>django</category></item></channel></rss>